*[English](README.md) ∙ [简体中文](README-zh-Hans.md) | [Brazilian Portuguese](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Farsi](https://github.com/donnemartin/system-design-primer/issues/110) . [Italian](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [Japanese](https://github.com/donnemartin/system-design-primer/issues/100) ∙ [Polish](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [Russian](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Traditional Chinese](https://github.com/donnemartin/system-design-primer/issues/88) ∙ [Turkish](https://github.com/donnemartin/system-design-primer/issues/39) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*
<div dir="rtl">

# مبانی طراحی سیستم

> سلام :) این ترجمه فارسی از یک منبع انگلیسی زبان هست. هدف از این ترجمه کمک به کسانی است که تا حدودی با زبان انگلیسی مشکل دارند( تا بتونن از محتویات آموزشی اون استفاده کنند). با این حال، اگر در زمینه برنامه نویسی و حوزه کامپیوتر فعالیت می‌کنید حتما به دنبال اون باشید که توانایی خودتون رو در مطالعه متن‌های انگلیسی تقویت کنید. آخر هر بخش سعی کردم ترجمه اصطلاحات لازم رو بیارم که کمکی کرده باشم در یادگیری شما. 

> در ترجمه این متن، سعی کردم که مفهوم رو منتقل کنم و از ترجمه کلمه به کلمه، که ممکنه باعث پیچیدگی بشه، خودداری کردم. با این حال در ادامه نحوه همکاری مشخص شده. خوشحال میشم کمک کنید تا این منبع رو به خوبی برای هم زبونای خودمون آماده کنیم. ممنون :)

<p align="center">
  <img src="http://i.imgur.com/jj3A5N8.png">
  <br/>
</p>

## هدف

> یادگیری نحوه طراحی سیستم‌های بزرگ-مقیاس
> کسب آمادگی برای شرکت در مصاحبه‌های طراحی سیستم

### یادبگیریم که چه طوری سیستم های مقیاس-بزرگ طراحی کنیم

اینکه چه طوری یک سیستم مقایس-بزرگ را طراحی کنیم کمک میکنه که یه مهندس بهتری بشیم. مبحث طراحی سیستم، یک بحث گسترده‌ای هست و برای این موضوع  **منابع زیادی داخل وب پراکنده وجود داره** . این مخزن یک مجموعه‌ی منظم و ساختاریافته از منابعی هست که به شما کمک میکنه، یاد بگیرید چه‌طوری سیستم‌های بسازید که بتونه در مقایس بزرگ کار کنه.

> System Design: طراحی سیستم, Large-Scale: مقیاس-بزرگ, Repository | Repo. : مخزن

### از جامعه متن‌باز یادبگیریم

این پروژه متن باز در حال کامل شدن هست و در حقیقت یک پیشنویسه.

از [کمک](#همکاری) به این پروژه استقبال میشه

> Open-Source: متن باز, Contributing : کمک کردن

### برای مصاحبه طراحی سیستم آماده شویم

علاوه‌بر آزمون کدنویسی در مصاحبه، در بسیاری از شرکت‌های  تکنولوژی طراحی سیستم یکی از **قسمت‌های لازم** در فرآیند **مصاحبه فنی** است.

**سوال‌های  مصاحبه طراحی سیستم را تمرین کنید** و جواب‌هاتون رو با **راهکارهای نمونه** داده شده **مقایسه** کنید: توضیحات،‌کد و دیاگرام‌ها

موضوعات بیشتر برای آمادگی در مصاحبه:

* [راهنمای مطالعه](#راهنمای-مطالعه)
* [چگونه به سوالات طراحی سیستم در مصاحبه پاسخ بدیم؟](#نحوه-برخورد-با-سوالات-مصاحبه-طراحی-سیستم)
* [سوالات مصاحبه طراحی سیستم **همراه با پاسخ**](#سوالات-مصاحبه-طراحی-سیستم-همراه-با-پاسخ)
* [سوالات مصاحبه طراحی شئ گرا **به همراه پاسخ**](#سوالات-مصاحبه-طراحی-شئ-گرا-به-همراه-پاسخ)
* [سوالات بیشتر در طراحی سیستم](#سوالات-بیشتر-مصاحبه-طراحی-سیستم)

## فلش کارتهای انکی

> انکی در واقع یک برنامه شبیه جی-۵ یا همان جعبه لایتنر هست. برای آشنایی بیشتر به لینک زیر برید:
>
> [Anki Flashcard](https://apps.ankiweb.net/)

<p align="center">
  <img src="http://i.imgur.com/zdCAkB3.png">
  <br/>
</p>

مجموعه‌ای از فلش کارت های انکی وجود داره که کمک میکنه به صورت دوره‌ای مفاهیم طراحی سیستم رو یادبگیرید.

 [Anki flashcard decks](https://apps.ankiweb.net/)

* [طراحی سیستم](resources/flash_cards/System%20Design.apkg)
* [تمرین‌های طراحی سیستم](resources/flash_cards/System%20Design%20Exercises.apkg)
* [تمرین‌های طراحی شیئ گرا](resources/flash_cards/OO%20Design.apkg)

برای استفاده در مسیر مناسبه.

### منبع برنامه نویسی: مساله‌های تعاملی برنامه نویسی

اگر به دنبال مخزنی میگیردید که به شما کمک کنه تا در مصاحبه برنامه نویسی شما رو آماده کنه لطفا به مخزن زیر مراجعه کنید:
</div>

> [**Coding Interview**](https://github.com/donnemartin/interactive-coding-challenges)
<div dir="rtl">

<p align="center">
  <img src="http://i.imgur.com/b4YtAEN.png">
  <br/>
</p>

همچنین مخزن دیگه‌ای وجود داره که میتونه فلش کارت‌های انکی بیشتری رو در اختیار شما بزاره. برای دسترسی به لینک زیر برید:
</div>

> [**Interactive Coding Challenges**](https://github.com/donnemartin/interactive-coding-challenges)
<div dir="rtl">

برای فلش کارت‌های انکی:
</div>

> [Coding deck](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)
<div dir="rtl">

## همکاری

> با کمک کامیونیتی یادبگیرید

برای کمک در موارد زیر پول-ریکوئست بدید:

* درست کردن خطاها
* بهبود بخش‌ها
* اضافه کردن بخش‌های جدید
* [ترجمه](https://github.com/donnemartin/system-design-primer/issues/28)

محتویاتی که نیاز به پرداختن بیشتر و اضافه کردن مطلب دارند در بخش [تحت توسعه](#تحت-توسعه) هستند. قسمت قوانین همکاری رو ببینید

>  [قوانین همکاری](CONTRIBUTING.md).

## فهرست موضوعات طراحی سیستم

> خلاصه‌ای از مباحث متنوع طراحی سیستم به همراه مزیت‌ها و معایت آنها. در حقیقت هرچیز یک تریدآف یا به عبارتی تعادلی بین مزایا و معایب هست. هر بخش شامل لینک‌هایی به منابعی هستند که به طور مفصل‌تر به موضوع مربوطه پرداختن.

> Scalability: مقایس پذیری , Performance: کارایی, Latency: تاخیر, Throughput: بازدهی, Availability: دسترس‌پذیری, Consistency: یکپارچگی

<p align="center">
  <img src="http://i.imgur.com/jrUBAF7.png">
  <br/>
</p>

* [مباحث طراحی سیستم: از اینجا شروع کنید](#مباحث-طراحی-سیستم:-از-اینجا-شروع-کنید)
    * [قدم اول: ویدیو مربوط به مقیاس پذیری رو ببنید](#قدم-۱-ویدیوهایی-درمورد-مقیاس-پذیری-رو-ببینید)
    * [قدم دوم: مقاله مربوط به مقیاس پذیری رو ببینید](#قدم-۲-مقاله‌های-مربوط-به-مقایس-پذیری-رو-ببینید)
    * [قدم های بعدی](#قدم‌های-بعدی)
* [کارایی در برابر مقایس پذیری](#کارایی-در-برابر-مقایس-پذیری)
* [تاخیر در برابر بازدهی](#تاخیر-در-برابر-بازدهی)
* [دسترس پذیری دربرابر یکپارچگی](#دسترس-پذیری-دربرابر-یکپارچگی)
    * [CAP تئوری](#cap-تئوری)
        * [CP - یکپارچگی و تحمل پارتیشن ](#CP-یکپارچگی-و-تحمل-پارتیشن)
        * [AP - دسترس پذیری و تحمل پارتیشن](#AP-دسترس-پذیری-و-تحمل-پارتیشن)
* [الگوهای یکپارچگی](#الگوهای-یکپارچگی)
    * [یکپارچگی ضعیف](#یکپارچگی-ضعیف)
    * [یکپارچگی موکول](#یکپارچگی-موکول)
    * [یکپارچگی قوی](#یکپارچگی-قوی)
* [الگوهای دسترس پذیری](#الگوهای-دسترس-پذیری)
    * [Fail-over](#fail-over)
    * [Replication](#replication)
* [سیستم نام دامنه](#سیستم-نام-دامنه-DNS)
* [شبکه توزیع محتوا - CDN](#شبکه-توزیع-محتوا-CDN)
    * [Push CDNs](#push-cdns)
    * [Pull CDNs](#pull-cdns)
* [لود بالانسر](#لود-بالانسر)
    * [توزیع بار لایه ۴](#توزیع-بار-لایه-۴)
    * [توزیع بار لایه ۷](#توزیع-بار-لایه-۷)
    * [مقیاس کردن افقی](#مقایس-پذیری-افقی)
* [وب سرور پروکسی معکوس - Reverse proxy (web server)](#وب-سرور-پروکسی-معکوس)
    * [توزیع کنند بار(لود بالانسر) دربرابر پروکسی معکوس](#لودبالانسر-دربرابر-پروکسی-معکوس)
* [لایه برنامه - Application layer](#لایه-برنامه)
    * [میکرو سرویس ها](#میکروسرویس-ها)
    * [کشف سرویس](#کشف-سرویس)
* [پایگاه داده](#پایگاه-داده)
    * [سیستم مدیریت رابطه‌ای پایگاه داده (RDBMS)](#مدیریت-رابطه‌ای-پایگاه-داده-RDBMS)
        * [Master-slave replication](#master-slave-replication)
        * [Master-master replication](#master-master-replication)
        * [Federation](#federation)
        * [Sharding](#sharding)
        * [Denormalization](#denormalization)
        * [SQL tuning](#sql-tuning)
    * [NoSQL](#nosql)
        * [Key-value store](#key-value-store)
        * [Document store](#document-store)
        * [Wide column store](#wide-column-store)
        * [Graph Database](#graph-database)
    * [SQL یا NoSQL](#sql-یا-nosql)
* [کش](#cache)
    * [کش سمت کلاینت](#کش-سمت-کلاینت)
    * [CDN کش در](#CDN-کش-در)
    * [Web server caching](#web-server-caching)
    * [کش پایگاه داده](#کش-پایگاه-داده)
    * [کش در برنامه](#کش-در-برنامه)
    * [کش در سطح کوئری پایگاه داده](#کش-در-سطح-کوئری-پایگاه-داده)
    * [کش در سطح اپجکت](#کش-در-سطح-آبجکت)
    * [چه زمانی کش را آپدیت کنیم؟](#چه-زمانی-کش-را-آپدیت-کنیم)
        * [Cache-aside](#cache-aside)
        * [Write-through](#write-through)
        * [Write-behind (write-back)](#write-behind-write-back)
        * [Refresh-ahead](#refresh-ahead)
* [Asynchronism](#asynchronism)
    * [Message queues](#message-queues)
    * [Task queues](#task-queues)
    * [Back pressure](#back-pressure)
* [ارتباط](#ارتباط)
    * [Hypertext transfer protocol (HTTP)](#Hypertext-transfer-protocol-(HTTP))
    * [Transmission control protocol (TCP)](#Transmission-control-protocol-(TCP))
    * [User datagram protocol (UDP)](#User-datagram-protocol-(UDP))
    * [Remote procedure call (RPC)](#Remote-procedure-call-(RPC))
    * [Representational state transfer (REST)](#Representational-state-transfer-(REST))
* [امنیت](#امنیت)
* [پیوست](#پیوست)
    * [جدول اعداد توان ۲](#جدول-اعداد-توان-۲)
    * [اعداد تاخیری که هر برنامه نویس باید بدونه](#اعداد-تاخیری-که-هر-برنامه-نویس-باید-بدونه)
    * [سوالات بیشتر مصاحبه طراحی سیستم](#سوالات-بیشتر-مصاحبه-طراحی-سیستم)
    * [معماری های دنیای واقعی](#معماری-های-دنیای-واقعی)
    * [معماری کمپانی‌ها](#معماری-کمپانی‌ها)
    * [وبلاگ‌های مهندسی کمپانی‌ها](#وبلاگ‌های-مهندسی-کمپانی‌ها)
* [تحت توسعه](#تحت-توسعه)
* [Credits](#credits)
* [اطلاعات تماس](#اطلاعات-تماس)
* [License](#license)

## راهنمای مطالعه

> مباحث پیشنهادی براساس مدت زمان مصاحبه شما(کوتاه، متوسط، بلند)آورده شده است

![Imgur](http://i.imgur.com/OfVllex.png)

**سوال: برای مصاحبه باید همه چیزی که اینجاست رو بدونم؟**

**پاسخ:نه. لازم نیست که همه مطالبی که اینجاست رو بدونید**

چیزی که از شما در مصاحبه پرسیده میشه بستگی به متغیرهای زیاده داره،‌ به عنوان مثال :

- میزان تجربه شما
- پیشینه فنی شما چی هست
- برای چه سمتی دارید مصاحبه می‌شید
- چه کمپانی داره با شما مصاحبه میکنه
- شانس

بیشتر کاندیداهای باتجربه ازشون انتظار میره که بیشتر در مورد طراحی سیستم بدونن. معمارها یا تیم لیدرها ممکنه ازشون انتظار بره که از آدمهای معمولی بیشتر بدونن. توی کمپانی‌های شاخ ممکنه که چند دور مصاحبه برای طراحی داشته باشند

خیلی کلی شروع کنید و بعد توی یه زمینه‌ای برید و عمیق بشید. این آموزش باعث میشه که شما در مورد مباحث مختلف طراحی سیستم یکم دانش کسب کنید. آموزش‌هایی که در ادامه میاد رو بر اساس موارد مختلفی مثل زمانی که دارید، تجربه‌ای که دارید، سمتی که دارید براش مصاحبه میرید و اینکه چه کمپانی دارید میرید تنظیم کنید.



* **اگر زمان مصاحبه کوتاهی دارید** - هدفتون باشه رو این که به صورت **موضوعی** مباحث طراحی سیستم رو بخونید از اینجا. برید سراغ حل **بعضی** از سوالات مصاحبه.
* **اگر زمان مصاحبتون متوسطه** - هدفتون باشه که هم به صورت **موضوعی** و هم **یکم عمقی** مباحث رو پیگیری کنید.توی این مرحله **تعداد زیادی** مساله حل کنید..
* **اگرزمان مصاحبتون زیاده** - هدفتون باشه که به صورت **موضوعی** و با **عمق زیاد** به مباحث طراحی سیستم بپردازید. سعی کنید تا می‌تویند سوالات بیشتری حل کنید.

|                                          |   فرصت کم   | فرصت متوسط |     فرصت زیاد      |
| ---------------------------------------: | :---------: | :--------: | :----------------: |
| برای درک کلی از این که سیستم‌ها به چه صورتی کار میکنن به قسمت [فهرست موضوعات طراحی سیستم](#فهرست-موضوعات-طراحی-سیستم) مراجعه کنید |    :+1:     |    :+1:    |        :+1:        |
| براساس کمپانی که قصد دارید برید مصاحبه، پست‌های  [وبلاگ مهندسی](#وبلاگ‌های-مهندسی-کمپانی‌ها) اون رو مطالعه کنید |    :+1:     |    :+1:    |        :+1:        |
| قسمت [معماری دنیای واقعی](#معماری-های-دنیای-واقعی) را به خوبی مطالعه کنید |    :+1:     |    :+1:    |        :+1:        |
| قسمت [نحوه برخورد با سوالات مصاحبه طراحی سیستم](#نحوه-برخورد-با-سوالات-مصاحبه-طراحی-سیستم) رو یه بررسی کنید |    :+1:     |    :+1:    |        :+1:        |
| به طور کامل روی قسمت [سوالات مصاحبه طراحی سیستم با پاسخ](#سوالات-مصاحبه-طراحی-سیستم-همراه-با-پاسخ)  کارکنید | بعضی قسمتاش | قسمت زیادش | تا اونجایی که میشه |
| به طور کامل روی قسمت [سوالات مصاحبه طراحی شئ گرا با پاسخ](#سوالات-مصاحبه-طراحی-شئ-گرا-به-همراه-پاسخ) کار کنید | بعضی قسمتاش | قسمت زیادش | تا اونجایی که میشه |
| قسمت [سوالات بیشتر مصاحبه طراحی سیستم](#سوالات-بیشتر-مصاحبه-طراحی-سیستم) رو یه بررسی کنید | بعضی قسمتاش | قسمت زیادش | تا اونجایی که میشه |

## نحوه برخورد با سوالات مصاحبه طراحی سیستم

> چه طوری با سوالات مصاحبه طراحی سیستم برخورد کنیم

مصاحبه طراحی سیستم شبیه یه مکالمه‌ای هست که جواب قطعی و مشخصی نداره. انتظار میره با جواب‌هایی که میدید روندش رو مشخص کنید. یعنی این که با جوابش صرفا یک بله یا خیر نیست و با جواب شما روند مصاحبه تغییر میکنه

شما میتونید از روشی که در ادامه میاد برای پیشبرد روند مصاحبه استفاده کنید. برای این کار به طور کامل روی قسمت [سوالات مصاحبه طراحی سیستم با پاسخ](#سوالات-مصاحبه-طراحی-سیستم-همراه-با-پاسخ) کار کنید البته به صورت قدم‌هایی که در ادامه آورده شدن

### قدم ۱: فرضیات، محدودیت‌ها و محل کاربرد رو خلاصه در بیارید

> use case: نمونه کاربرد, schema: شِما

نیازمندی‌ها و اسکوپ مساله‌ای که قراره حل کنید رو دربیارید. یه سری سوال بپرسید تا بیاد دستتون که محدودیت‌ها و کاربرد‌های این سیستم چیه و بعد روی فرضیات بحث کنید.

- چه کسی قراره از این سیستم استفاده کنه؟
- اون کسایی که استفاده میکنن، چطوری قرار استفاده کنند؟
- چقدر کاربر توی این سیستم هست؟
- سیستم چی کار میکنه؟
- ورودی و خروجی سیستم چیا هستن؟
- چقدر داده قراره که سیستم هندل کند؟
- چه تعداد درخواست در ثانیه انتظار داریم؟
- چه نسبتی از خوندن به نوشتن مورد انتظارمونه؟

### قدم ۲: یک طراحی سطح بالا درست کنید

یه طراحی سطح بالا و کلی از اجزای مهم بکشید

- اجزای اصلی و ارتباطشون رو بکشید
- ایده هاتون رو باهاش تایید کنید و بررسی کنید ببینید درسته یا نه

### قدم۳: المان‌های اصلی‌تر سیستم رو طراحی کنید

سراغ جزئیات بیشتر، برای هر المان اصلی‌تر و مهم، برید. به عنوان مثال اگر ازتون خواستن که [یک سرویس برای کوتاه کردن لینک](#طراحی-سرویس-کوتاه-کردن-لینک) طراحی کنید، موارد زیر رو بررسی کنید:

- تولید و ذخیره سازی یک هش کامل از لینک
  - [MD5](solutions/system_design/pastebin/README.md) و [Base62](solutions/system_design/pastebin/README.md)
  - Hash collisions
  - SQL یا NoSQL
  - شمای پایگاه داده
- تبدیل یک لینک هش شده به لینک کامل اصلیش
  - نحوه پیداکردنش از پایگاه داده
- اِی-پی-آی و طراحی شئ گرا

### قدم۴: طراحی رو اسکیل کنید

> Bottleneck: باتِلنِک, Sharding: شاردینگ

با توجه به محدودیت‌هایی که داده شده مشکلات و باتلنک‌ها رو پیدا کنید. برای مثال، آیا برای حل این مشکلات به موارد زیر نیاز پیدا میکنید؟

- لود بالانسر
- Horizontal scaling | مقیاس پذیری افقی
- کش کردن
- شاردینگ پایگاه داده

روش‌ها و ترید-آف های محتمل رو مورد بحث و بررسی قرار بدید. هر چیزی یک ترید-آف هست. مشکلات و باتلنک ها رو با استفاده از  [اصول طراحی سیستم های مقایس پذیر](#فهرست-موضوعات-طراحی-سیستم) مورد بررسی و چالش قرار بدید و بیان کنید.

### محاسبات سریع

> Back-of-the-envelop calculations: محاسبات سریع

ممکنه که ازتون بخوان که یه سری تخمین‌ها رو دستی بزنید. برای این قضیه به قسمت [پیوست](#پیوست) برید و از منابعی که اونجاست استفاده کنید

- [استفاده از محاسبات پشت کاغذی](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)
- [جدول اعداد توان ۲](#جدول-اعداد-توان-۲)
- [اعداد تاخیری که هر برنامه نویس باید بدونه](#اعداد-تاخیری-که-هر-برنامه-نویس-باید-بدونه) 

### منابع برای مطالعه بیشتر

از لینک‌های زیر میتونید استفاده کنید تا بیاد دستتون که مصاحبه طراحی سیستم چه جوریه و منتظر چه چیزایی باشید توش:
</div>

* [How to ace a systems design interview](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)
* [The system design interview](http://www.hiredintech.com/system-design)
* [Intro to Architecture and Systems Design Interviews](https://www.youtube.com/watch?v=ZgdS0EUmn70)
<div dir="rtl">

## سوالات مصاحبه طراحی سیستم همراه با پاسخ

> سوالات عمومی که در مصاحبه طراحی سیستم پرسیده میشه به همراه پاسخ‌های نمونه و نمودار و کد‌های اون آورده شده. این پاسخ‌های در پوشه زیر قرار داره.
>
>  `solutions/`

> Key-Value Store: محل ذخیره مقدار, Crawler: خزنده, AWS: ای-دبلیو-اس

|                                          |                                     سوال |
| :--------------------------------------: | ---------------------------------------: |
| [پاسخ](solutions/system_design/pastebin/README.md) |           Pastebin.com (or Bit.ly) طراحی |
| [پاسخ](solutions/system_design/twitter/README.md) | طراحی تایملاین توییتر یا فید فیسبوک<br/>طراحی سرچ توییتر یا سرچ فیسبوک |
| [پاسخ](solutions/system_design/web_crawler/README.md) |                        طراحی یک خزنده وب |
| [پاسخ](solutions/system_design/mint/README.md) |                               Mint طراحی |
| [پاسخ](solutions/system_design/social_graph/README.md) | طراحی ساختمان داده برای شبکه‌های اجتماعی |
| [پاسخ](solutions/system_design/query_cache/README.md) | طراحی یک محل ذخیره به مدل کلید-مقدار برای یک موتور جست و جو |
| [پاسخ](solutions/system_design/sales_rank/README.md) | طراحی رنکینگ سایت آمازون در قسمت فروش بر اساس ویژگی |
| [پاسخ](solutions/system_design/scaling_aws/README.md) | طراحی سیستمی که بتونه به تعداد میلیون کاربر روی زیرساخت آمازون اِی-دبلیو-اس اسکیل کنه |
|             [کمک کنید](#کمک)             |              سوال طراحی سیستم اضافه کنید |

### Pastebin.com (or Bit.ly) طراحی 

[مشاهده تمرین و پاسخ](solutions/system_design/pastebin/README.md)

![Imgur](http://i.imgur.com/4edXG0T.png)

### طراحی تایملاین و سرچ توییتر یا فید و سرچ فیسبوک

[مشاهده تمرین و پاسخ](solutions/system_design/twitter/README.md)

![Imgur](http://i.imgur.com/jrUBAF7.png)

### طراحی خزنده وب

[مشاهده تمرین و پاسخ](solutions/system_design/web_crawler/README.md)

![Imgur](http://i.imgur.com/bWxPtQA.png)

### طراحی Mint.com

[مشاهده تمرین و پاسخ](solutions/system_design/mint/README.md)

![Imgur](http://i.imgur.com/V5q57vU.png)

### طراحی ساختمان داده برای شبکه‌های اجتماعی

[مشاهده تمرین و پاسخ](solutions/system_design/social_graph/README.md)

![Imgur](http://i.imgur.com/cdCv5g7.png)

### طراحی یک محل ذخیره به مدل کلید-مقدار برای یک موتور جست و جو

[مشاهده تمرین و پاسخ](solutions/system_design/query_cache/README.md)

![Imgur](http://i.imgur.com/4j99mhe.png)

### طراحی رنکینگ سایت آمازون در قسمت فروش بر اساس ویژگی

[مشاهده تمرین و پاسخ](solutions/system_design/sales_rank/README.md)

![Imgur](http://i.imgur.com/MzExP06.png)

### طراحی سیستمی که بتونه به تعداد میلیون کاربر روی زیرساخت آمازون اِی-دبلیو-اس اسکیل کنه

[مشاهده تمرین و پاسخ](solutions/system_design/scaling_aws/README.md)

![Imgur](http://i.imgur.com/jj3A5N8.png)

## سوالات مصاحبه طراحی شئ گرا به همراه پاسخ

> سوالات عمومی که در مصاحبه طراحی شئ گرا پرسیده میشه به همراه پاسخ‌های نمونه و نمودار و کد‌های اون آورده شده. این پاسخ‌های در پوشه زیر قرار داره.
>
>  `solutions/`

> Hash-Map: هش-مپ, Least Recently Used Cache: کش به صورت آخرین کمترین استفاده شده, Circular Array: آرایه چرخشی

>**توجه: این بخش درحال توسعه هست**

|                                          |                                     سوال |
| :--------------------------------------: | ---------------------------------------: |
| [پاسخ](solutions/object_oriented_design/hash_table/hash_map.ipynb) |                              طراحی هش-مپ |
| [پاسخ](solutions/object_oriented_design/lru_cache/lru_cache.ipynb) | طراحی یک کش به صورت آخرین کمترین استفاده شده |
| [پاسخ](solutions/object_oriented_design/call_center/call_center.ipynb) |                       طراحی یک مرکز تماس |
| [پاسخ](solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb) |                  طراحی یه دسته کارت بازی |
| [پاسخ](solutions/object_oriented_design/parking_lot/parking_lot.ipynb) |                         طراحی یک پارکینگ |
| [پاسخ](solutions/object_oriented_design/online_chat/online_chat.ipynb) |                         طراحی یک سرور چت |
|             [کمک کنید](#کمک)             |                     طراحی یک آرایه چرخشی |
|             [کمک کنید](#کمک)             |  سوالات بیشتر طراحی شئ‌گرا رو اضافه کنید |

## مباحث طراحی سیستم: از اینجا شروع کنید

تازه با طراحی سیستم آشنا شدید؟

در ابتدا لازمه که یک سری اصول اولیه رو یاد بگیرید که شامل این هستن که این اصول چین، چه شکلی استفاده میشن و مزایا و معایبشون چیه

### قدم ۱ ویدیوهایی درمورد مقیاس پذیری رو ببینید

[Scalability Lecture at Harvard](https://www.youtube.com/watch?v=-W9F__D3oY4)

* مباحثی که پوشش داده میشه:
    * Vertical scaling | مقایس پذیری عمودی
    * Horizontal scaling | مقایس پذیری افقی
    * Caching‌ | کش کردن
    * Load balancing |  لودبالانسینگ یا توزیع بار
    * Database replication | ریپلیکِیشن در پایگاه داده
    * Database partitioning | پارتیشن کردن در پایگاه داده

### قدم ۲ مقاله‌های مربوط به مقایس پذیری رو ببینید

[Scalability](http://www.lecloud.net/tagged/scalability)

* مباحثی که پوشش داده شده:
    * [Clones |‌ کلون‌ها](http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
    * [Databases | پایگاه‌داده ها](http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
    * [Caches | کش‌ها](http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
    * [Asynchronism | ناهمگام سازی](http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)

### قدم‌های بعدی

در قدم بعدی، به ترید-آف های سطح بالاتری میپردازیم مثل:

* **کارایی** دربرابر **مقایس پذیری**
* **تاخیر** دربرابر **بازدهی**
* **دسترسی پذیری** دربرابر **یکپارچگی**

یادتون باشه که **همه چیز یک ترید-آف هست**

در ادامه به مباحث زیر میپردازیم:

DNS, CDNs, load balancers.

## کارایی در برابر مقایس پذیری

> Scalable: مقایس پذیر , Performance: کارایی

یک سرویس رو **مقایس پذیر** میگیم وقتی که متناسب با منابعی که به سیستم اضافه میکنیم **کارایی** اون هم افزایش پیدا بکنه. به طورکلی منظور از افزایش کارایی اینه که تعداد کار بیشتری رو انجام بدیم اما ممکنه که کارهای باحجم بزرگتر هم بتونه هندل کنه مثل زمانی که مجموعه داده هامون زیاد میشه و رشد میکنه<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>

یه روش دیگه برای نگاه به قضیه کارایی و مقایس پذیری به صورت زیر هست:

* اگر شما مشکل کارایی دارید، سیستم شما برای یک کاربر کند کار میکنه
* اگر شما مشکل مقیاس پذیری دارید، سیستم شما برای یک کاربر سریعه ولی برای بار زیاد، کُند عمل میکنه

### منابع برای مطالعه بیشتر
</div>

* [A word on scalability](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)
* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
<div dir="rtl">

## تاخیر در برابر بازدهی

>  Latency: تاخیر, Throughput: بازدهی

**تاخیر** مدت زمانی هست که باید *کاری* انجام بشه یا نتیجه‌ای تولید بشه.

**بازدهی** میزان تعداد همین کارهای انجام شده یا نتیجه‌های گرفته شده هست که باید توی واحد زمان انجام بشه.

به طور کلی شما باید برای **بیشترین بازدهی** به همراه **تاخیر قابل قبول** برنامه ریزی کنید.

### منابع برای مطالعه بیشتر
</div>

* [Understanding latency vs throughput](https://community.cadence.com/cadence_blogs_8/b/sd/archive/2010/09/13/understanding-latency-vs-throughput)
<div dir="rtl">

## دسترس پذیری دربرابر یکپارچگی

> Availability: دسترس‌پذیری, Consistency: یکپارچگی, Partition Tolerance: تحمل پارتیشن

### CAP تئوری

<p align="center">
  <img src="http://i.imgur.com/bgLMI2u.png">
  <br/>
  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>Source: CAP theorem revisited</a></i>
</p>

در سیستم‌های توزیع شده کامپیوتری شما تنها میتونید که ۲ تا از گارانتی‌های زیر رو تضمین کنید:

* **یکپارچگی** - هر عملیات خواندن، نزدیکترین داده‌ای که تازه نوشته شده رو میگیره یا با خطا مواجه میشه
* **دسترس پذیری** - هر درخواست یک پاسخ میگیره، بدون هیچ تضمینی که جدیدترین نسخه از اطلاعات رو بگیره.
* **تحمل پارتیشن** - سیستم میتونه به عملیات خودش ادامه علی رغم اینکه به خاطر خطاهای شبکه مجبور به پارتیشن بنده شده باشه 

*شبکه ها قابل اتکا و اطمینان نیستن، بنابریان لازمه که شما تحمل پارتیشن رو پشتیبانی کنید و داشته باشید. بنابراین باید بین یکپارچگی و دسترس پذیری یک ترید-آف انجام بدید و یکی رو انتخاب کنید*

#### CP یکپارچگی و تحمل پارتیشن

> Atomic: اتمیک, Timeout: تایم-اوت

صبر و انتظار برای گرفتن جواب از یک نود پارتیشن شده ممکنه باعث بشه تا تایم-اوت بگیریم.اگر سیستم شما نیاز داره که به صورت اتمیک بخونه و بنویسیه ،  این مدل یک انتخاب مناسبه

#### AP دسترس پذیری و تحمل پارتیشن

پاسخهایی که دریافت میشه حاوی جدیدترین نسخه از داده‌ است که روی اون نود وجود داره. نوشتن ممکنه نیاز به زمان داشته باشه تا در کل سیستم اعمال بشه

این مدل انتخاب خوبیه اگر شما نیاز به [یکپارچگی موکول](#یکپارچگی-موکول) دارید یا  سیستم نیاز داره که مستقل از خطاهای خارج از خودش(خطاهای خارجی) به علمکردش ادامه بده

### منابع برای مطالعه بیشتر
</div>

* [CAP theorem revisited](http://robertgreiner.com/2014/08/cap-theorem-revisited/)
* [A plain english introduction to CAP theorem](http://ksat.me/a-plain-english-introduction-to-cap-theorem/)
* [CAP FAQ](https://github.com/henryr/cap-faq)
<div dir="rtl">

## الگوهای یکپارچگی

زمانی که تعدادی کپی از داده‌های یکسان داریم، با مجموعه‌ای از انتخاب‌ها درباره این که چطوری کلاینت‌ها رو سینکرون نگه داریم موجه می‌شیم تا همه یک نمای یکسان از داده داشته باشند. با توجه به تعریف یکپارچگی از [تئوری کپ](#CAP-تئوری) - هر عملیات خوندن، نزدیک ترین نسخه از داده نوشته شده رو می‌گردونه یا خطا میده.

### یکپارچگی ضعیف

بعد از این که یک عملیات نوشتن انجام شد، عملیات خوندن ممکنه اونو ببینه یا نبینه. بهترین روش برای خوندن انتخاب میشه.

این روش در سیستم‌های نظیر مِم-کش-دی دیده میشه. یکپارچگی ضعیف در سیستم‌های با نیاز بلادرنگ مثل وویپ، ویدیو چت و بازی‌های بلادرنگ چندنفره کاربرد داره. برای مثال، اگر شما پشت تلفن باشید و چند ثانیه ارتباط قطع بشه و بعد دوباره وصل بشید، اون چیزی که گفته شده رو دیگه از دست دادید.

### یکپارچگی موکول

بعد از اینکه یک عملیات نوشتن انجام شد، عملیات‌های خوندن نهایتا(در حد چند میلی ثانیه) اونو میبینن. داده به صورت ناهمگام در جاهای دیگه کپی و تکرار میشه

این روش در سیستم‌هایی نظیر دی-اِن-اِس و ایمیل دیده میشه. در سیستم‌های با دسترس پذیری بالا به خوبی کار میکنه.

### یکپارچگی قوی

بعد از اینکه عملیات نوشتن انجام شد، عملیات‌های خوندن اونو میبینن. داده به صورت همگام کپی و تکرار می‌شه.

این روش معمولا در فایل سیستم‌ها و مدیریت پایگاه داده‌رابطه‌ای دیده میشه. در سیستم‌هایی که نیاز به تراکنش دارند این مدل به خوبی عمل میکنه.

### منابع برای مطالعه بیشتر
</div>

* [Transactions across data centers](http://snarfed.org/transactions_across_datacenters_io.html)
<div dir="rtl">

## الگوهای دسترس پذیری

دو مدل برای پشتیبانی از دسترس پذیری بالا وجود داره:

**fail-over** و **replication**.

### Fail-over

> Heartbeat: هارت-بیت, Hot: هات , Cold Startup: شرایط لود سرد, Master-Salve: مستر-اِسلِیو, Master-Master: مستر-مستر

#### Active-passive

در این مدل، هارت-بیت بین سرور فعال و سرور غیر فعال که درحالت آماده باشه، رد و بدل میشه. اگر هارت-بیت قطع بشه سرور غیرفعال آی-پی سرور فعال رو دراختیار می‌گیره و درخواست‌ها رو هندل می‌کنه.

طول زمان پایین بودن به دو نوع معین میشه، یا اینکه سرور غیر فعال در حالت به اصطلاح هات در انتظاره یا نیاز داره از حالت به اصطلاح سرد شروع به کار کنه. فقط سرور فعال ترافیک رو هندل میکنه.

این مدل رو مستر-اِسلِیو هم میگن

#### Active-active

در این حالت هر دو سرور ترافیک رو هندل میکنن و بار بین این دو تقسیم میشه.

اگر سرورها به صورت عمومی روی اینترنت قابل دسترسی باشن، دی-اِن-اِس باید آی-پی هر دو سرور رو بدونه. اگر سرورها در شبکه داخلی باشن، لایه برنامه باید از حضور این دو سرور آگاهی داشه باشه.

این مدل به عنوان مستر-مستر هم شناخته میشه.

### معایب Fail-over

* این الگو نیاز به سخت افزار بیشتری داره و پیچیدگی رو هم افزایش میده
* اگر یک سیستم فعال فِیل بشه و فرصت نشه تا داده جدیدی که تازه نوشته شده، بتونه کپی بشه توی سرور غیرفعال، امکان از دست رفتن داده هست.

### Replication

#### Master-Slave و Master-Master

این موضوع در بخش [پایگاه داده](#پایگاه-داده) بررسی شده

* [تکرارکردن مستر-اسلیو](#master-slave-replication)
* [تکرارکردن-مستر-مستر](#master-master-replication)

## سیستم نام دامنه DNS

> A/B Testing: آ-ب تست, DDos-Attack: حمله دی-داس, ISP: آی-اِس-پی, DNS: دی-ان-اس

<p align="center">
  <img src="http://i.imgur.com/IOyLj4i.jpg">
  <br/>
  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>Source: DNS security presentation</a></i>
</p>

سیستم نام دامنه یا همان دی-اِن-اِس، نام یک دامنه را به آی-پی آن ترجمه میکند.
</div>

www.example.com ->  IP address.
<div dir="rtl">

دی-اِن-اِس به صورت سلسله مراتبی هست و تعداد کمی سرور اصلی در لایه‌های بالا وجود داره. روتر یا آی-اِس-پی شما اطلاعات مربوط به دی-ان-اس هایی که برای جستجو استفاده میشن رو در اختیار شما میزارن. دی-ان-اس های لایه پایین‌تر معمولا این نگاشت بین نام دامنه و آی-پی رو کش میکنن به خاطر این که انتشار تغییرات در دی-ان-اس کنده، که ممکنه بعد از مدتی اعتبار این نگاشت‌ها از بین بره . نتایجی که از دی-ان-اس برای شما میاد ممکنه که در مرورگر یا سیستم عامل برای مدت مشخصی کش بشه، به این مدت مشخص تایم-تو-لیو گفته میشه

> [time to live (TTL)](https://en.wikipedia.org/wiki/Time_to_live) : تایم-تو-لیو

* **NS record (name server)**  - این رکورد سرورهای دی-ان-اس مربوط به دامنه یا زیردامنه رو مشخص میکنه

* **MX record (mail exchange)** - مِیل-سرورهای شما برای دریافت پیامها رو مشخص میکنه

* **A record (address)** - یک نام رو به یک آی-پی نگاشت میکنه

* **CNAME (canonical)** - یک نام رو به نام دیگه یا سی-نیم یا اِی-رکورد دیگه نگاشت میکنه. به مثال زیر توجه کنید
</div>

  * > example.com -> www.example.com
<div dir="rtl">

سرویسهای نظیر سرویس های زیر سرویس‌ دی-ان-اس مدیریت شده رو ارائه میکنن

[CloudFlare](https://www.cloudflare.com/dns/) و [Route 53](https://aws.amazon.com/route53/)

بعضی از سرویس‌های دی-ان-اس میتونن ترافیک رو با روش‌های مختلفی، مثل روش‌های زیر، ارسال کنند:

* [Weighted round robin](http://g33kinfo.com/info/archives/2657)
    * از ارسال ترافیک به سرورهایی که در حال نگهداری هستند خودداری میکنه
    * براساس سایز کلاستری که هست میتونه بالانس ایجاد کنه
    * برای آ-ب تستینگ
* Latency-based |‌براساس تاخیر
* Geolocation-based | براساس موقعیت جغرافیایی

### معایب: دی-ان-اس

* دسترسی به سرور دی-ان-اس یک تاخیری رو موجب میشه که با استفاده از کشینگ گفته شده برطرف میشه.

* مدیریت سرورهای دی-ای-اس ممکنه پیچیده باشه با این حال توسط دولت ها،‌آی-اس-پی ها و کمپانی‌های بزرگ مدیریت میشه
</div>

  * > [governments, ISPs, and large companies](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729).
<div dir="rtl">

* سرویس دی-ان-اس اخیرا مورد حمله دی-داس قرارگرفته و باعث شده تا دسترسی کاربران به وب سایتها  قطع بشه، وب سایت‌هایی نظیر توییتر - به اینصورت که کاربرا آی-پی توییتر رو نمیتونستن پیدا کنن
</div>

  * >  [DDoS attack](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/) 
<div dir="rtl">

### منابع برای مطالعه بیشتر
</div>

* [DNS architecture](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)
* [Wikipedia](https://en.wikipedia.org/wiki/Domain_Name_System)
* [DNS articles](https://support.dnsimple.com/categories/dns/)
<div dir="rtl">

## شبکه توزیع محتوا CDN

> CDN: سی-دی-ان, Time-to-live: تایم-تو-لیو, Push CDN: پوش سی-دی-ان, Pull CDN: پول سی-دی-ان

<p align="center">
  <img src="http://i.imgur.com/h9TAuGI.jpg">
  <br/>
  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>Source: Why use a CDN</a></i>
</p>

> HTML: اِچ-تی-اِم-اِل, CSS: سی-اِس-اِس , Javascript: جاوااسکریپت

یک شبکه توزیع محتوا یا سی-دی-ان یک شبکه توزیع شده از پروکسی سرورهاست که محتوا را از مکان‌هایی که به کاربر نزدیکتره به دستشون میرسونه. به طور کلی فایل‌های ایستا مثل اِچ-تی-اِم-اِل، جاوااسکریپت و سی-اِس-اِس، عکس، ویدیو از طریق سی-دی-ان به کاربر داده میشه. با این حال سی-دی-ان هایی نظیر کلود-فرانت که برای شرکت آمازون است محتوای غیر ایستا یا داینامیک رو هم پشتیبانی میکنه. عملیات سوال از دی-ان-اس برای یه سایت به کاربر میگه که باید به کدوم سرور متصل بشه.

انتشار محتوا از طریق سی-دی-ان ها میتونه باعث افزایش کارایی چشمگیری بشه. این افزایش به خاطر ۲ علت زیره:

* کاربران محتوا را از دیتاسنتری که بهشون نزدیکه میگیرن.
* سرورهای شما احتیاجی نیست که به درخواستی پاسخ بدن که سی-دی-اِن میتونه پاسخ بده

### Push CDNs

پوش سی-دی-ان زمانی که سرورشما تغییری روی محتوا داشته باشه، تغییرات رو می‌گیره. در این حالت، شما مسوول آماده کردن محتوا برای سی-دی-ان هستید، باید محتوا رو مستقیم آپلود کنید روی سی-دی-اِن و یو-آر-اِل ها رو دوباره نویسی کنید که به سی-دی-ان اشاره کنه. میتونید تنظیم کنید که چه زمانی محتوایی که گذاشتید مدت استفادش از بین بره و چه زمانی آپدیت بشه. محتوا زمانی آپلود میشه که یا جدید باشه یا تغییر پیدا کرده باشه. اینکار باعث کاهش ترافیک میشه ولی افزایش میزان حافظه هم داره.

سایت‌هایی که ترافیک کمی دارند یا محتوایی دارند که آپدیت نمیشه اغلب اوقات با این مدل پوش سی-دی-ان به خوبی کار میکنن. به جای اینکه طی یه بازه‌ی مشخصی همینطور از سرور محتوا آورده بشه توی سی-دی-اِن، محتوا یکبار در سی-دی-ان گذاشته میشه

### Pull CDNs

وقتیکه کاربر اولین درخواست برای یک محتوای جدید رو میده، پول سی-دی-ان اون محتوا جدید رو از سرور شما می‌گیره . شما محتوا رو روی سرورتون می‌زارید و یو-آر-ال هاش روی سی-دی-ان تنظیم می‌کنید. تا وقتی که محتوا روی سی-دی-ان کش بشه، این کار باعث میشه درخواستها کندتر بشن .

یک تایم-تو-لیو مدت زمانی که محتوا باید کش بشه رو مشخص میکنه. پول سی-دی-اِن میزان استورج روی سی-دی-اِن رو کم میکنه اما میتونه ترافیک اضافی هم ایجاد کنه اگر فایل‌ها قبل از این که به سی-دی-اِن بیان مدت کش اونها منتقضی بشه.

>  [time-to-live (TTL)](https://en.wikipedia.org/wiki/Time_to_live): تایم-تو-لیو

سایتهای با ترافیک سنگین خیلی خوب با این مدل پول سی-دی-ان کار میکنن چون که با  آخرین درخواست برای محتوای تازه  درخواست شده روی سی-دی-اِن مواجه میشه، ترافیک به صورت یکسان پخش میشه.

### معایب: CDN

* هزینه‌ها خیلی وابسته به ترافیکیه که وجود داره با این حال این این هزینه ها رو درکنار هزینه‌های استفاده نکردن از سی-دی-ان درکنار هم ببینید.
*  محتوا ممکنه قبل از این که تایم-تو-لیو اون تموم بشه، منقضی بشه
*  برای محتوای ایستا یو-آر-ال ها باید تغییر کنه و به سی-دی-اِن اشاره کنه.

### منابع برای مطالعه بیشتر
</div>

* [Globally distributed content delivery](http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&context=compsci)
* [The differences between push and pull CDNs](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)
* [Wikipedia](https://en.wikipedia.org/wiki/Content_delivery_network)
<div dir="rtl">

## لود بالانسر

<p align="center">
  <img src="http://i.imgur.com/h81n9iK.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Source: Scalable system design patterns</a></i>
</p>

لودبالانسرها  درخواست هایی که از سمت کاربران میاد رو بین منابع محاسباتی که هست مثل اپلیکیشن سرورها یا پایگاه داده‌ها توزیع میکنه. در هر کدوم از این حالات، لودبالانسر پاسخ درخواست رو از اون منبع محاسباتی به کاربر برمیگردونه. لودبالانسر ها در مورد زیر موثر هستند:

* از رفتن درخواست ها به سرورهایی که سالم نیستن جلوگیری میکنه

* از زیربار رفتن بیش از اندازه منابع جلوگیری میکنه

* کمک میکنه که سیستم از شکست نقطه‌ای آسیب پذیره نباشه

  * > Single Point of Failure: شکست نقطه‌ای

لودبالانسرها میتونن به صورت سخت افزاری پیاده سازی بشن(که گرون میشه) یا به صورت نرم افزاری پیاده سازی بشن مثلا برنامه زیر

>  HAProxy

مزایای دیگه هم داره، به طور مثال:

* **SSL termination** - درخواست هایی که از سمت کاربر میاد را رمزگشایی میکنه و جوابهایی که باید سرور بده رو هم رمزنگاری میکنه بنابراین سرورها لازم نیست تا این عملیاتهای سنگین محاسباتی رو انجام بدن
    * از نصب گواهی‌های ایکس.۵۰۶ روی هر سرور جلوگیری میکنه

      * > [X.509 certificates](https://en.wikipedia.org/wiki/X.509) 
* **Session persistence** -  اگر برنامه وب سِشِن نگه نداره، کوکی سِت میکنه و هربار ترافیک مربوط به درخواست یک کاربر رو  به یک سرور یکسان میده 

برای جلوگیری از فِیل سیستم، یک کاری که مرسومه اینه که چندتا لودبالانسر تنظیم میشه که با دو مود زیر میتونه باشه

>  [active-passive](#active-passive) , [active-active](#active-active) .

لودبالانسرها میتونن ترافیک رو براساس معیارهای مختلفی پخش کنن:

* Random
* Least loaded
* Session/cookies
* [Round robin یا weighted round robin](http://g33kinfo.com/info/archives/2657)
* [لایه ۴](#توزیع-بار-لایه-۴)
* [لایه ۷](#توزیع-بار-لایه-۷)

### توزیع بار لایه ۴

> Packet: پکت

لودبالانسرهای لایه ۴ به اطلاعاتی که در لایه‌ی ترسنپورت است نگاه میکنند و تصمیم میگیرن که چه‌طوری درخواست‌ها رو پخش کنند. به طورکلی یعنی نگاه به اطلاعاتی نظیر مبدا درخواست، آی-پی مقصد و پورت هایی که در هدر وجود دارد، اما به محتوای پکتی که ارسال میشود نگاهی نمیشود. این نوع لودبالانسرها پکت‌های شبکه را به سرورهای بالادستی ارسال و یا از آنها دریافت میکنن که به این صورت عملیات ترجمه آدرس شبکه انجام میشه.

> [transport layer](#ارتباط): لایه ترنسپورت
> [Network Address Translation (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/): ترجمه آدرس شبکه

### توزیع بار لایه ۷

> Upstream: بالادستی

لودبالانسرها میتونن کمکی باشن برای اسکیل کردن افقی و باعث افزایش کارایی و دسترس پذیری بشن. اسکیل کردن

لودبالانسرهای لایه ،۷ به لایه‌ی برنامه نگاه می‌کنند و تصمیم می‌گیرند که چه‌طوری درخواست ها رو پخش کنند. این کار میتونه با استفاده از داده هایی که در هدر، محتوای پیام و کوکی‌هاست صورت بپذیره. این لودبالانسرها ترافیک شبکه رو تموم میکنه یعنی تا تهش میگیره، پیام رو میخونه و یک تصمیم برای توزیع بار میگیره و بعدش یک کانکشن به سروری که حاصل تصمیمش هست ایجاد میکنه. برای مثال، یه لود بالانسر لایه ۷ میتونه ترافیک‌های مربوط به ویدیو رو به یک سرور بفرسته درحالیکه ترافیک‌هایی که مربوط به قبض‌های پرداختی میشه رو به یک سرور دیگه ای که از نظر امنیتی قوی تر هست بفرسته.

با احتساب هزینه‌ای که بابت انعطاف پذیری،‌ لودبالانسینگ لایه ۴ نیاز به منابع و زمان کمتری داره نسبت به لایه ۷ ، با این حال کاراییش روی سیستم‌های مدرن معمولی میتونه کم اثر باشه.

### مقایس پذیری افقی

> Upstream: بالادستی, Downstream: رو به پایین. سروری که ازش دانلود میشه بیشتر, Horizontal Scaling: مقایس کردن افقی, Vertical Scaling: مقایس کردن عمودی

لودبالانسرها میتونن کمکی باشن برای اسکیل کردن افقی و باعث افزایش کارایی و دسترس پذیری بشن. اسکیل کردن با استفاده از سیستم‌های عادی تر(تعداد ماشین‌ها رو زیاد کنیم) خیلی از نظر هزینه به صرفه تره و باعث میشه تا دسترس پذیری بیشتری داشته باشیم تا این که بیایم یک سرور رو از نظر سخت افزاری ارتقا بدیم که معمولا گرون میشه، که بهش میگن **مقیاس کردن عمودی**. همینطور کار با یک سیستم عادی خیلی آسونتره واسه آدما تا اینکه بخوان با سیستم‌های تخصصی شده برای کارای سطح کلان کار کنن.

#### معایب: مقایس پذیری افقی

* مقیاس پذیری افقی باعث پیچیدگی میشه و باید سرور‌های کلون شده ایجاد کنید.

    * Servers should be stateless: این سرور‌ها نباید حاوی داده‌هایی باشن که مخصوص کاربراس مثل سشن‌ها یا عکس پروفایل کاربرا

    * سشن‌ها میتونن توی یک مرکز ذخیره سازی داده مرکزی ذخیره بشن مثلا پایگاه داده یا یک کش با قابلیت نگهدارندگی دائمی 

        * > [پایگاه‌داده](#پایگاه-داده) (SQL, NoSQL) 
          > [کش](#cache) (Redis, Memcached)

* سرور‌هایی که معمولا ترافیک دانلودشوندگی دارند مثلا کش‌ها یا پایگاه‌داده‌ها نیازدارند که تعداد کانکشن‌های همزمان بیشتری رو نسب به سرور‌های بالادستی هندل کنن

### معایب: لود بالانسر

* لودبالانسر میتونه گلوگاه مشکل کارایی باشه اگر منابع لازم به اندازه کافی نداشته باشه یا اگر اینکه به درستی تنظیم نشده باشه
* با استفاده از لودبالانسر مشکل شکست نقطه‌ای از بین میره ولی میزان پیچیدگی رو زیاد میکنه
* یک دونه لودبالانسر میتونه خودش یک شکست نقطه‌ای باشه با این حال با تنظیم چندتا لودبالانسر پیچیدگی هم زیاد میشه.

### منابع برای مطالعه بیشتر
</div>

* [NGINX architecture](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [HAProxy architecture guide](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Scalability](http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
* [Wikipedia](https://en.wikipedia.org/wiki/Load_balancing_(computing))
* [Layer 4 load balancing](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)
* [Layer 7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)
* [ELB listener config](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)
<div dir="rtl">

## وب سرور پروکسی معکوس

<p align="center">
  <img src="http://i.imgur.com/n41Azff.png">
  <br/>
  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>Source: Wikipedia</a></i>
  <br/>
</p>

یک پروکسی معکوس، یک وب سروی هست که سرویس‌ها داخلی رو تجمیع میکنه و باعث میشه که از بیرون به یک واسط یکارچه دسترسی داشته باشید. درخواست‌ها از کلاینت‌ها فوروارد میشن به سروری که میتونه درخواست رو جواب بده قبل از اینکه پروکسی معکوس جواب رو به کاربر برگردونه.

مزایای بیشترش شامل موارد زیر میشه:

* **Increased security** - اطلاعات مربوط به سرور‌های بک-اند رو مخفی میکنه، میتونه آی-پی ها رو بلک-لیست کنه و تعداد کانکشن‌ها برای هر کلاینت رو محدود کنه
* **Increased scalability and flexibility** - کلاینت‌ها فقط آی-پی پروکسی معکوس رو می‌بینن و این اجازه میده که شما سرور‌ها تون رو اسکیل کنید یا تنظیماتش رو تغییر بدید
* **SSL termination** - میتونه درخواست‌های ورودی رو رمزگشایی کنه و جواب‌هایی که سرور میفرسته رو رمز گذاری کنه تا این عملیات محاسباتی سنگین از دوش سرور برداشته بشه.
    * نیاز به نصب گواهی‌های ایکس.۵۰۹ رو روی هر سرور نداره

      * > [X.509 certificates](https://en.wikipedia.org/wiki/X.509) 
* **Compression** - فشرده سازی جواب‌های سرور
* **Caching** - برای درخواست‌هایی که کش شدن میتونه جوابشون رو از روی کش بده
* **Static content** - میتونه محتوای ایستا رو به صورت مستقیم جواب بده
    * HTML/CSS/JS
    * عکس‌ها
    * فیلم‌ها
    * غیره

### لودبالانسر دربرابر پروکسی معکوس

* اگر تعداد سرور زیادی دارید استفاده از لودبالانسر بهتره. معمولا لودبالانسر ترافیک رو بین سرورهایی که یک کار مشابه انجام میدن توزیع میکنه.

* پروکسی معکوس‌ها، حتی زمانی که شما یه دونه وب سرور یا اپلیکیشن سرور دارید میتونن مفید باشن. مزایی که قبلا اشاره شد رو برای شما فراهم میکنن.

* برنامه‌های زیر هر دو میتونن که لودبالانسینگ و پروکسی معکوس لایه ۷ انجام بدن 

  * > NGINX و HAProxy

### معایب: پروکسی معکوس

* باعث افزایش پیچیدگی میشه
* یک دونه پروکسی معکوس میتونه یه شکست نقطه‌ای باشه و با تنظیم کردن چندتا از این پروکسی سرورها(به عنوان مثال به صورت [فِیل-اُوِر](https://en.wikipedia.org/wiki/Failover)) باعث افزایش پیچیدگی میشه.

### منابع برای مطالعه بیشتر
</div>

* [Reverse proxy vs load balancer](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)
* [NGINX architecture](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [HAProxy architecture guide](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Wikipedia](https://en.wikipedia.org/wiki/Reverse_proxy)
<div dir="rtl">

## لایه برنامه

<p align="center">
  <img src="http://i.imgur.com/yB5SYwm.png">
  <br/>
  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Source: Intro to architecting systems for scale</a></i>
</p>

> Single Responsibility Principle(SRP): اصل تک مسولیتی, Asynchronism: ناهمگامی, Worker: وُرکر

جداسازی لایه وب از لایه برنامه(که بعضا به عنوان لایه پلتفرم هم شناخته میشه) به شما این امکان رو میده که هر دو لایه رو مستقل از هم دیگه اسکیل کنید. اضافه کردن یک اِی-پی-آی جدید به لایه‌ی برنامه مستقل از اینکه به وب سرور بخواید چیزی اضافه کنید انجام میشه.

**اصل تک مسولیتی** به دنبال این هست که سرویس‌های کوچک و خودمختاری رو داشته باشه که بتونن باهم کار کنن. تیم‌های کوچیک با سرویس‌های کوچیک میتونن خیلی سریع‌تر و قوی‌تر برای رشد برنامه ریزی کنند.

وُرکرهایی که در لایه برنامه هستند باعث میشن تا قابلیت [ناهمگامی](#asynchronism) رو بتونیم داشته باشیم.

### میکروسرویس ها

> Well-defined: خوش تعریف

مرتبط با این بحث مبحث  [میکروسرویس‌ها](https://en.wikipedia.org/wiki/Microservices) است که میتونیم به عنوان مجموعه‌ای از سرویس‌های ماژولار، کوچک و قابل دیپلوی شدن مستقل تعریف کرد. هر سرویس یک پروسس یکتایی رو اجرا میکنه و از طریق یک پروتکل ارتباطی سبک و خوش تعریف با بقیه سرویس‌ها در ارتباطه تا یک هدف تجاری رو به سرانجام برسونه <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>

پینترسنت به عنوان مثال میتونه سرویس‌هایی نظیر پروفایل کاربر، فید فالور‌ها، فالورها، جستجو، اپلود عکس و ... رو داشته باشه. 

### کشف سرویس

سیستم هایی نظیر کنسول، ای-تی-سی-دی و زووکیپر با نگهداشتن اطلاعات در مورد اسم‌ها و آدرس‌ها و پورت‌های سرویس‌ها کمک کنن تا سرویس‌ها بتونن همدیگه رو پیدا کنند.

> [Consul](https://www.consul.io/docs/index.html): کنسول, [Etcd](https://coreos.com/etcd/docs/latest): ای-تی-سی-دی, [Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper): زوو-کیپر

چک-سلامت سرویس‌ها کمک میکنه که درستی و یکپارچگی سیستم بررسی بشه و معمولا از اِند-پوینت های اچ-تی-تی-پی استفاده میشه.

>  [Health checks](https://www.consul.io/intro/getting-started/checks.html): چک-سلامت [HTTP](#hypertext-transfer-protocol-http) endpoint: اِند-پوینت اچ-تی-تی-پی

هر دو سرویس کنسول و ای-تی-سی-دی یک ذخیره‌ساز کلید-مقدار در درون خودشون دارند که برای مواردی مثل ذخیره کردن کانفیگ ها و یا داده‌هایی که باید به اشتراک باشن، میتونه مفید باشه.

> [key-value store](#key-value-store): ذخیره کلید-مقدار 

### معایب: لایه برنامه

* اضافه کردن لایه برنامه‌ای که کمترین وابستگی رو داشته باشه نیاز داره که در سطح معماری، عملیات و فرآیند، راهکار متفاوتی رو اتخاذ بکنه(در برابر حالت سیستم یکدست(
* میکروسرویس‌ها میتونن در دیپلوی کردن و عملیات مربوطه پیچیدگی اضافه کنن

### منابع برای مطالعه بیشتر
</div>

* [Intro to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale)
* [Crack the system design interview](http://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview/)
* [Service oriented architecture](https://en.wikipedia.org/wiki/Service-oriented_architecture)
* [Introduction to Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)
* [Here's what you need to know about building microservices](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)
<div dir="rtl">

## پایگاه داده

<p align="center">
  <img src="http://i.imgur.com/Xkm5CXz.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=vg5onp8TU6Q>Source: Scaling up to your first 10 million users</a></i>
</p>

### مدیریت رابطه‌ای پایگاه داده RDBMS

یک پایگاه‌داده رابطه‌ای مثل اس-کیو-اِل مجموعه‌ای از داده‌هاس که در جداول قرار گرفتند.

**اسید** مجموعه‌ای از ویژگی‌های هست که برای تراکنش‌های پایگاه داده رابطه‌ای استفاده میشه. 

> [transactions](https://en.wikipedia.org/wiki/Database_transaction): تراکنش

* **Atomicity** - هر تراکنشی یا کامل اتفاق میوفته یا اصلا نمیشه
* **Consistency** - هر تراکنش باعث میشه که پایگاه داده از یک حالت درست به حالت درست دیگه بره
* **Isolation** - اجرای تراکنش‌ها به صورت همزمان همان خروجی رو خواهد داشت که اگر اونا رو پشت سرهم/سریالی اجرا میشدن
* **Durability** - زمانی که یک تراکنش انجام میش، باقی میمونه 

 روش‌های مختلفی برای اسکیل کردن پایگاه‌داده‌های رابطه‌ای وجود داره: 
 </div>
 
**master-slave replication**, **master-master replication**, **federation**, **sharding**, **denormalization**, and **SQL tuning**.
<div dir="rtl">

#### Master-slave replication

مستر هم عملیات خواندن و هم نوشتن رو انجام میده، نوشتن‌ها رو برای ۱ یا تعداد بیشتری از اسلیوها تکرار میکنه، اسلیوها فقط عملیات خواندن رو انجام میدن. اسلیو‌ها هم میتونن خودشون به صورت درختی یک سری اسلیو دیگه رو مثل خودشون تکرار کنن. اگر نود مستر خاموش بشه یا کلا از دسترس خارج بشه، سیستم کار خودش رو به صورت حالت فقط-خواندنی ادامه تا زمانی که یکی از این نودهای اسلیو  تبدیل بشه به مستر یا یه مستر دیگه اضافه بشه.

<p align="center">
  <img src="http://i.imgur.com/C9ioGtn.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>
</p>

##### معایب: master-slave replication

* یه مکانیزم منطقی اضافی میخواد که بتونه نود اسلیو رو به نود مستر ارتقا بده

* به قسمت زیر برید چون نکاتش مشترک هست

  * > [معایب: replication](#معایب-replication) 

#### Master-master replication

هردوی مستر‌ها عملیات خواندن و نوشتن را انجام میدن و زمانی که قصد انجام نوشتن دارند باهم هماهنگ میشن. اگر یکی از این مسترها پایین بیاد، سیستم میتونه با هر دو عملیات خواندن و نوشتن کارش رو ادامه بده.

<p align="center">
  <img src="http://i.imgur.com/krAHLGg.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>
</p>

##### معایب: master-master replication

* شما نیاز به یک لودبالانسر دارید یا اینکه باید در لایه برنامه‌تون تغییراتی ایجاد کنید که مشخص کنه کجا بنویسه.

* بیشتر سیستمهای مستر-مستر به صورت یکپارچه-ضعیف هستند(که مخالف اصل اَسید هست) یا باعث میشه که تاخیر عملیات نوشتن به خاطر نیاز به همگامسازی افزایش پیدا کنه.

  * > ACID: اَسید, Synchronization: همگامسازی, Loosely-Consistent: ناهمگون-ضعیف

*  اگر تعداد نودهای نوشتن بیشتر و بیشتر بشه،  رفع تداخل بیشتر اتفاق میوفته و همینطور میزان تاخیرهم زیاد میشه.

* قسمت زیر رو ببنید چرا که نکات مشترک هستند برای مستر-مستر و مستر-اسلیو

  * > [معایب: replication](#معایب-replication)

##### معایب replication

* اگر نود مستر، قبل از اینکه عملیات نوشتنی که به تازگی اتفاق افتاده، نتونه رو نودهای دیگه تکرارکنه و در این حین پایین بیاد یا فِیل بشه، امکان این هست که داده‌ها از بین برن.
* عملیات‌های نوشتن روی نودهای خواندن تکرار میشه. اگر تعداد نوشتن‌ها خیلی زیاد بشه نودهای خواندن به خاطر تکرار عملیات نوشتن هنگ میکنن و نمیتونن تعداد عملیات‌های خواندن زیادی انجام بدن
* هرچه تعداد نودهای اسلیو برای خواندن بیشتر باشه،‌باید تعداد بیشتری عملیات رو روی این نودها تکرار کنید که این خودش باعث میشه که شما یک لگ برای عملیات تکرار کردن داشته باشید
* روی بعضی سیستم ها نوشتن روی مستر میتونه به صورت ایجاد چند تِرِد برای نوشتن موازی  انجام بگیره اما روی نودهای خواندنی فقط یک تِرِد میتونه عملیات نوشتن رو انجام بده که اونم به صورت پشت سرهم انجام میشه.
* ریپلیکیشن باعث میشه تا سخت افزار بیشتری اضافه بشه و پیچیدگی رو افزایش میده.

##### منابع برای مطالعه بیشتر: replication
</div>

* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Multi-master replication](https://en.wikipedia.org/wiki/Multi-master_replication)
<div dir="rtl">

#### Federation

<p align="center">
  <img src="http://i.imgur.com/U3qV33e.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=vg5onp8TU6Q>Source: Scaling up to your first 10 million users</a></i>
</p>

فِدِرِیشن ( یا تقسیم عملکردی) پایگاه داده‌ها رو براساس کاری که انجام میدن تکه تکه میکنه. برای مثال به جای یک پایگاه‌داده یک-تکه، شما میتونید ۳ تا پایگاه داده داشته باشید. **انجمن ها**،**کاربران** و  **محصولات** باعث میشه تا تعداد عملیات‌های خواندن و نوشتن کم بشه و در نتیجه لگی که به خاطر عملیات ریپلیکیشن هست کاهش پیدا کنه. پایگاه‌داده‌های کوچک‌تر باعث میشن تا داده‌های بیشتری بتونه توی رم قراربگیره و این باعث میشه تا نتایج بیشتری، به خاطر اصل محلی بودن، در کش پیدابشن . بدون داشتن یک نود مستر مرکزی برای انجام عملیات‌های نوشتن می‌تونید تعداد نوشتن‌ها رو به صورت موازی انجام بدید که این باعث میشه تا بازدهی بیشتری داشته باشید.

##### معایب: federation

* اگر شِمای شما نیاز به توابع یا جداول بزرگ باشه موثر نیست

* شما باید لایه منطق برنامه تون رو به روز کنید تا برنامه بتونه بفهمه به کدوم پایگاه‌داده باید عملیات نوشتن یا خوندن رو بفرسته.

* انجام عملیات جوین از دوتا پایگاه داده میتونه خیلی پیچیده باشه. لینک زیر رو ببنید

  * > [server link](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers): جوین ۲ تا پایگاه داده

* باعث افزایش سخت افزار و افزودن پیچیدگی میشه

##### منابع بیشتربرای مطالعه :‌ federation
</div>

* [Scaling up to your first 10 million users](https://www.youtube.com/watch?v=vg5onp8TU6Q)
<div dir="rtl">

#### Sharding

<p align="center">
  <img src="http://i.imgur.com/wU8x5Id.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>
</p>

شاردینگ داده‌ها رو در پایگاه داده‌های مختلفی توزیع میکنه. این توزیع به این صورت هست که هر پایگاه داده فقط بخشی از داده اصلی رو در خودش داره. به عنوان مثال پایگاه داده مربوط به کاربران رو در نظر بگیرید، هرچه تعداد کاربران افزایش پیدا کنه تعداد شارد‌هایی که باید اضافه بشه به کلاستر هم افزایش پیدا میکنه.

مشابه مزیت‌هایی مربوط [فدریشن](#federation) ، شاردینگ باعث میشه تا تعداد ترافیک خواندن و نوشتن کم بشه و ریپلیکیشن رو هم کم کنه و وجود داده در کش رو هم افزایش میده. سایز ایندکس‌ها هم کم میشه که بهطورکلی باعث میشه تا کارایی رو افزایش بده و سرعت کوئری ها رو زیاد کنه. اگر یک شاردی بیاد پایین، بقیه‌ی شاردها هنوز کار میکنن با این حال شما باید یه فرآیند ریپلیکیشن اضافه کنید که داده از بین نره. شبیه فدریشن، هیچ نودمرکزی برای نوشتن به صورت پشت سرهم وجود نداره و باعث میشه تا نوشتن به صورت موازی صورت بگیره و بازدهی افزایش پیدا کنه. 

راه‌های عمومی برای شارد کردن جدول کاربران وجود داره، هم براساس اسم فامیلی کاربر میشه، هم براساس اسم کوچیکشون یا موقعیت جغرافیاییشون.

##### معایب: sharding

* باید منطق لایه برنامه رو تغییر بدید تا بتونه با شاردها کارکنه که این باعث میشه تا کوئری های اس-کیو-ال پیچیده بشن.
* توزیع داده ها میتونه نامتوازن باشن توی یه شارد. برای مثال یه مجموعه ای از کاربران روی یک شارد باعث بشن که لود روی اون بیشتر از بقیه بشه.
    * دوباره بالانس کردن باعث میشه تا پیچیدگی رو افزایش بده. یک تابع شاردینگ براساس یک تابع نگاشت استوار میتونه میزان انتقال داده‌ها رو کاهش بشده.

      * > [consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html): نگاشت-استوار
* جوین داده‌ها از چندتا شارد خیلی پیچیده میشه
* باعث افزایش سخت افزار و افزودن پیچیدگی میشه

##### منابع برای مطالعه بیشتر :‌ sharding
</div>

* [The coming of the shard](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)
* [Shard database architecture](https://en.wikipedia.org/wiki/Shard_(database_architecture))
* [Consistent hashing](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)
<div dir="rtl">

#### Denormalization

دی-نرمالایزکردن در ازای افزایش چند عملیات نوشتن، سعی میکنه که باعث افزایش کارایی خواندن بشه . یه سری کپی از داده‌ها توی جدول‌های مختلف نوشته میشه تا از سربار سنگین جوین جلوگیری کنه. بعضی از آر-دی-بی-اِم-اِس ها مثل [پوست-گِرِس](https://en.wikipedia.org/wiki/PostgreSQL) و اوراکل از [ویو-متریالایز](https://en.wikipedia.org/wiki/Materialized_view) پشتیبانی میکنن که کمک میکنه که اطلاعات اضافی رو ذخیره کنید و کپی داده‌ها رو با هم سازگار نگه دارید.

زمانی که داده‌ها به روش [فدریشن](#federation) و [شاردینگ](#sharding) توزیع میشن مدیریت جوین‌ها بین دیتا سنترهای باعث میشه که پیچیدگی خیلی زیاد بشه. دی-نرمالایزیشن شاید باعث بشه که این نیاز به این نوع جوین  ها رو از ببره.

دربیشتر سیستم‌ها عملیات خوندن میتونه به نسبت ۱۰۰:۱ یا حتی ۱۰۰۰:۱ نسبت به عملیات نوشتن بیشتر باشه.  عملیات خوندنی که حاصل یک جوین پیچیده پایگاه‌داده باشه، میتونه خیلی سنگین باشه و مدت زمان قابل توجی روی عملیات‌های مربوط به ‌دیسک سپری کنه.

##### معایب: denormalization

* داده‌ها چندجا یکسان کپی میشن و تکراری داریم
* محدودیت ها میتونه کمک کنه که کپی‌های داده ‌ها با هم سینک بمونن، که این کار باعث میشه تا طراحی پایگاه داده رو پیچیده کنید
* پایگاه‌داده دی-نرمالایز شده، زیر عملیات‌های سنگین نوشتن ممکنه کارایی خیلی بدی داشته باشه نسبت به مشابه نرمالایز شدش

###### منابع بیشتر برای مطالعه :‌denormalization
</div>

* [Denormalization](https://en.wikipedia.org/wiki/Denormalization)
<div dir="rtl">

#### SQL tuning

تون-کردن اس-کیو-ال یک مبحث خیلی گسترده‌ای است و تعداد    [کتاب‌های](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning)  زیادی در این زمینه به عنوان منبع نوشته شده است.

خیلی مهمه که شما **بنچمارک** و **پروفایل** کنید تا بتونید چالش‌های دیده نشده رو شبیه سازی کنید و پیداشون کنید

* **Benchmark** -   شبیه‌سازی شرایط لود زیاد با ابزارهایی مثل [اِی-بی](http://httpd.apache.org/docs/2.2/programs/ab.html) 
* **Profile** - فعال کردن ابزارهایی مثل [لاگ کوئری‌های کُند](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html) برای پیدا کردن مشکلات کارایی

بنچمارک کردن و پروفایل کردن ممکنه که شما رو به سمت بهینه سازی های زیر برسونه
</div>

##### Tighten up the schema

* MySQL dumps to disk in contiguous blocks for fast access.
* Use `CHAR` instead of `VARCHAR` for fixed-length fields.
    * `CHAR` effectively allows for fast, random access, whereas with `VARCHAR`, you must find the end of a string before moving onto the next one.
* Use `TEXT` for large blocks of text such as blog posts.  `TEXT` also allows for boolean searches.  Using a `TEXT` field results in storing a pointer on disk that is used to locate the text block.
* Use `INT` for larger numbers up to 2^32 or 4 billion.
* Use `DECIMAL` for currency to avoid floating point representation errors.
* Avoid storing large `BLOBS`, store the location of where to get the object instead.
* `VARCHAR(255)` is the largest number of characters that can be counted in an 8 bit number, often maximizing the use of a byte in some RDBMS.
* Set the `NOT NULL` constraint where applicable to [improve search performance](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search).

##### Use good indices

* Columns that you are querying (`SELECT`, `GROUP BY`, `ORDER BY`, `JOIN`) could be faster with indices.
* Indices are usually represented as self-balancing [B-tree](https://en.wikipedia.org/wiki/B-tree) that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time.
* Placing an index can keep the data in memory, requiring more space.
* Writes could also be slower since the index also needs to be updated.
* When loading large amounts of data, it might be faster to disable indices, load the data, then rebuild the indices.

##### Avoid expensive joins

* [Denormalize](#denormalization) where performance demands it.

##### Partition tables

* Break up a table by putting hot spots in a separate table to help keep it in memory.

##### Tune the query cache

* In some cases, the [query cache](http://dev.mysql.com/doc/refman/5.7/en/query-cache) could lead to [performance issues](https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/).
<div dir="rtl">

##### منابع برای مطالعه بیشتر :‌ SQL tuning
</div>

* [Tips for optimizing MySQL queries](http://20bits.com/article/10-tips-for-optimizing-mysql-queries-that-dont-suck)
* [Is there a good reason i see VARCHAR(255) used so often?](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)
* [How do null values affect performance?](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)
* [Slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)
<div dir="rtl">

### NoSQL

نو-اس-کیو-ال مجموعه‌ای از داده‌هاست که به صورت های مختلفی از جمله موارد زیر نمایش داده میشوند

**key-value store**, **document-store**, **wide column store**,  **graph database**

داده ها دی-نرمالایز میشن و جوین های معمولا در لایه ی برنامه انجام میشن. بیشتر نو-اس-کیو-ال ها از اصل **اَسید** برای تراکنش های پشتیبانی نمیکنن و [یکپارچگی موکول](#یکپارچگی-موکول) رو به این اصل ترجیح میدن 

**بِیس** معمولا برای توصیف ویژگی‌های پایگاه داده های نو-اس-کیو-ال استفاده میشه. در مقایسه با تئوری کپ ، بِیس دسترس پذیری رو بر یکپارچگی ترجیح میده.

> [تئوری CAP](#CAP-تئوری) 
> Consistent: سازگار

* **Basically available** -  سیستم دسترس‌پذیری رو تضمین میکنه
* **Soft state** - وضعیت سیستم ممکنه که بدون گرفتن ورودی در طول زمان دچار تغییر بشه.
* **Eventual consistency** - سیستم در طول یک مدت زمان سازگار میشه با این شرط که در طول این مدت ورودی نگیره

علاوه براین که باید انتخاب کنید که [اس-کیو-ال یا نو-اس-کیو-ال](#SQL-یا-NoSQL)  بد نیست انواع پایگاه داده های نو-اس-کیو-ال رو بشناسید و اونی که بهترین انتخاب برای کاربردتون هست را انتخاب کنید. ما در ادامه موارد زیر روبررسی میکنیم.

**key-value stores**, **document-stores**, **wide column stores**,  **graph databases**

#### Key-value store

> Abstraction: hash table
>
> O(1): اُ-۱, SSD: اِس-اِس-دی

یک ذخیره ساز کلید-مقدار به طور عمومی به شما این امکان رو میده که از عملیات خوندن و نوشتن رو با اُ(۱) انجام بدید و معمولا توسط حافظه‌های اِس-اِس-دی و رَم پشتیبانی میشن.  این ذخیره کننده‌های داده میتونن کلیدها رو به [به ترتیب الفبایی](https://en.wikipedia.org/wiki/Lexicographical_order) مرتب نگه دارن که باعث میشه تا بازیابی کلید‌ها به صورت بازه‌ای، بهینه تر و به صرفه‌تر بشه.

این ذخیره‌کننده ها معمولا با کارایی بالاهستند و برای مدل‌های داده‌ای ساده یا داده‌هایی که خیلی سریع تغییر می‌کنند مثل داده‌هایی که توی کش هستند مورد استفاده قرار می‌گیرند.

یک ذخیره‌ساز کلید-مقدار معمولا پایه‌ای اصلی برای سیستم‌های پیچیده‌ای مثل ذخیره‌ساز های اَسنادی و در بعضی موردها پایگاه‌داده‌های گرافی،‌مورد استفاده قرار میگیرد.

> Document Store: ذخیره ساز اسنادی

##### منابع برای مطالعه بیشتر‌ : key-value store
</div>

* [Key-value database](https://en.wikipedia.org/wiki/Key-value_database)
* [Disadvantages of key-value stores](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)
* [Redis architecture](http://qnimate.com/overview-of-redis-architecture/)
* [Memcached architecture](https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/)
<div dir="rtl">

#### Document store
</div>

> Abstraction: key-value store with documents stored as values
<div dir="rtl">

یک ذخیره‌ساز اسنادی حول ایده اسناد شکل میگیره(مانند ایکس-ام-ال، جِیسان، باینری و ...) که در اینجا یک سند تمام اطلاعات مربوط به یک شی رو در خودش ذخیره میکنه. ذخیره‌سازهای اسنادی، اِی-پی-آی ها یا زبان‌های کوئری در اختیار قرار میدهند تا بتونیم ساختار داخلی خود سند رو مورد جستجو و کوئری قرار بدیم. به یاد داشته باشید که خیلی از ذخیره‌سازهای کلید-مقدار شامل ویژگی‌هایی هستند که میتونه با متادیتاهای مربوط به مقدارهای یک کلید هم کارکنه، که باعث میشه که مرز بین این ذخیره‌سازها از لحاظ نوع محل ذخیره‌سازی با یکدیگه کمرنگتر بشه . 

براساس پیاده‌سازی های زیرساختی ، اسناد هم به صورت تگها، کالکشن‌ها، متادیتاها یا پرونده‌ها سازماندهی میشن. باوجوداینکه اسناد میتونن باهم دیگه گروه بشن یا توی یه دسته سازماندهی بشن،‌با اینحال میتونن هرکدوم فیلدهای مخصوص خودشون رو داشته باشند که در بقیه موجود نباشه.

بعضی از این ذخیره‌سازها مثل [مونگو-دی-بی](https://www.mongodb.com/mongodb-architecture#) و [کوچ-دی-بی](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/#) زبان‌هایی شبیه اس-کیو-ال برای انجام کوئری‌های پیچید‌ه فراهم کردند. [داینامو-دی-بی](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf#) هر دو نوع کلید-مقدار و اسنادی رو پشتیبانی میکنه.

ذخیره‌ساز های اسنادی انعطاف زیادی رو میدن و معمولا جاهایی که تغییرات داده مکرر اتفاق میوفته استفاده میشه.

##### منابع برای مطالعه بیشتر : document store
</div>

* [Document-oriented database](https://en.wikipedia.org/wiki/Document-oriented_database)
* [MongoDB architecture](https://www.mongodb.com/mongodb-architecture)
* [CouchDB architecture](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)
* [Elasticsearch architecture](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)
<div dir="rtl">

#### Wide column store

<p align="center">
  <img src="http://i.imgur.com/n16iOGk.png">
  <br/>
  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>Source: SQL & NoSQL, a brief history</a></i>
</p>
</div>

> Abstraction: nested map `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`
<div dir="rtl">

> Super Column Family: اَبَر-ستون‌-خانوادگی, Column Family ستون‌-خانوادگی: , Row Key: کلید سطر

المان اصلی و پایه‌ای برای ذخیره‌ساز واید-کالِم، ستون(یک جفت اسم/مقدار) است. یه ستون میتونه توی ستون‌های-خانوادگی (مثل همون جدول توی اس-کیو-ال) دسته بندی بشه. اَبَر-ستون‌های-خانوادگی به صورت دسته‌ای از ستون‌های-خانوادگی هستند. شما میتونید به هر ستونی که میخواید، با استفاده از کلید اون سطر، به صورت مستقل دسترسی داشته باشید. ستونها با یک کلید سطر مشابه، یه سطر رو تشکلی میدن. هر مقدار شامل یک استمپ-زمانی برای ورژنگذاری و رفع تداخل است.

گوگل [بیگ-تیبل](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) رو به عنوان اولین ذخیره‌ساز ستونی معرفی کرد که در [اچ-بیس](https://www.mapr.com/blog/in-depth-look-hbase-architecture)، که متن باز است و در اکوسیستم هدوپ استفاده میشه، و یا [کاساندرا](http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html)، که برای فیسبوک است، مورد استفاده قرار گرفته. ذخیره‌سازهایی مثل بیگ-تیبل،‌اچ-بیس و کاساندرا کلید‌ها رو به‌صورت الفبایی-مرتب نگهداری میکنن که باعث میشه که بازیابی براساس یک رنج از کلیدها به صورت موثر تر و بهینه تر باشه

ذخیره‌سازهای ستونی دسترس‌پذیری بالا و قابلیت اسکیل شدن بالا رو دراختیار قرار میدن. معمولا برای مجموعه داده‌های خیلی بزرگ مورد استفاده قرار میگیرند.

##### منابع برای مطالعه بیشتر : wide column store
</div>

* [SQL & NoSQL, a brief history](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)
* [Bigtable architecture](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)
* [HBase architecture](https://www.mapr.com/blog/in-depth-look-hbase-architecture)
* [Cassandra architecture](http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html)
<div dir="rtl">

#### Graph database

<p align="center">
  <img src="http://i.imgur.com/fNcl65g.png">
  <br/>
  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>Source: Graph database</a></i>
</p>

> Abstraction: graph

در یک پایگاه داده گرافی هر نود یک رکورد است و هر یال یک رابطه بین دو نود. پایگاه‌داده‌های گرافی برای نمایش رابطه‌های پیچیده مورد استفاده قرار میگیرند که معمولا تعداد کلید خارجی‌ زیاد یا رابطه‌های چند-به-چند زیادی دارند.

پایگاه‌داده های گرافی دارای کارایی بالا هستند و برای مدل‌های داده‌ای که روابط پیچیده دارند مورد استفاده قرار میگیرند مانند شبکه‌های اجتماعی. این دسته از پایگاه‌داده‌ها تقریبا جدید هستند و خیلی مورد استفاده قرار نگرفته اند،‌معمولا پیدا کردن منابع و یا ابزار برای این دست از پایگاه‌داده ها دشواره. خیلی از پایگاه داده های گرافی معمولا از طریق [رِست ای-پی-آی](#representational-state-transfer-rest) قابل دسترسی هستند.

##### منابع برای مطالعه بیشتر :‌ graph
</div>

* [Graph database](https://en.wikipedia.org/wiki/Graph_database)
* [Neo4j](https://neo4j.com/)
* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)
<div dir="rtl">

#### منابع بیشتر برای مطالعه : NoSQL
</div>

* [Explanation of base terminology](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)
* [NoSQL databases a survey and decision guidance](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)
* [Scalability](http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
* [Introduction to NoSQL](https://www.youtube.com/watch?v=qI_g07C_Q5I)
* [NoSQL patterns](http://horicky.blogspot.com/2009/11/nosql-patterns.html)
<div dir="rtl">

### SQL یا NoSQL

<p align="center">
  <img src="http://i.imgur.com/wXGqG5f.png">
  <br/>
  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>Source: Transitioning from RDBMS to NoSQL</a></i>
</p>



دلایلی که باید از **اس-کیو-ال** باید استفاده کرد:

* داده‌ها دارای ساختار هستند
* شِمای مورد استفاده خیلی قطعی و مشخص
* داده‌های رابطه‌ای
* نیاز به جوین های پیچیده دارید
* نیاز به تراکنش‌ها هست
* یک الگوی مشخص برای اسکیل کردن دارید
* از نظر تعداد توسعه دهنده، جامعه پشتبان، کد، ابزار و ... بیشتر موجوده
* جستوجو با استفاده از ایندکس‌ها خیلی سریع تره

دلایل برای استفاده از نو-اس-کیو-ال:

* داده‌های شبه-ساختار یافته
* شمای داده‌ها داینامیکه یا انعطافپذیره
* داده‌های غیر رابطه‌ای
* نیاز به جوین های پیچیده ندارید
* حجم داده‌ها در حد ترابایت یا پتا بایت هست
* حجم‌کاریتون خیلی داده محور هست
* میزان بازدهی بالا براساس آی-اُ بر ثانیه

نمونه‌هایی از مواردی که برای نو-اس-کیو-ال خیلی مناسبه:

* حجم‌زیاد داده‌های مربوط به لاگ یا کلیک کردن‌ها
* لیدربوردها در بازی ها یا داده‌های مربوط به امتیاز
* داده‌های موقت مثل اطلاعات کارت‌های خرید
* جداولی که تعداد درخواست برای داده‌های اون زیاده
* جداولی که برای متادیتا هست یا برای جستوجو استفاده میشن

##### منابع بیشتر برای مطالعه : SQL or NoSQL
</div>

* [Scaling up to your first 10 million users](https://www.youtube.com/watch?v=vg5onp8TU6Q)
* [SQL vs NoSQL differences](https://www.sitepoint.com/sql-vs-nosql-differences/)
<div dir="rtl">

## Cache

<p align="center">
  <img src="http://i.imgur.com/Q6z24La.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Source: Scalable system design patterns</a></i>
</p>

کش کردن باعث میشه تا زمان لود صفحه بهبود پیدا کنه و میتونه لود روی سرور شما و یا پایگاه داده رو کم کنه. در این مدل دیسپچر اول داخل کش رو نگاه میکنه اگر که درخواست قبلا داده شده بود و نتیجش بود اونجا، برمیگردونه به کاربر که باعث میشه زمان واقعی اجرا رو صرفه جویی کنه.

پایگاه داده‌ها معمولا از یک توزیع یکنواختی از خواندن ها یا نوشتنها توی پارتیشن بهره میگرن. آیتم‌هایی که خیلی مورد استفاده هستند میتونن این توزیع رو دچار چلگی کنن که باعث میشه که ما باتِلنِک داشته باشیم. استفاده از کش در جلوی پایگاه داده میتونه کمک کنه که این توزیع غیر یکنواخت و پیک‌های ترافیک رو جلوشو بگیره.

### کش سمت کلاینت

کشها میتونن که در بخش کلاینت (مثل مرورگر یا سیستم عامل) قرار بگیرند یا در [سمت سرور](#وب-سرور-پروکسی-معکوس) باشن یا کلا یک لایه کش جدا وجود دارشته باشه

### CDN کش در

[سی-دی-ان ها](#شبکه-توزیع-محتوا-CDN) به عنوان یک نوع از کش درنظر گرفته میشن

### Web server caching

[پروکسی ها معکوس](#وب-سرور-پروکسی-معکوس) و کش‌ها مثل [وارنیش](https://www.varnish-cache.org/) میتونن محتوای ایستا و داینامیک رو به صورت مستقیم جوابگو باشن. وب سرورهای هم میتونن درخواست‌ها رو کش کنن و جواب‌ها رو بدون اینکه به لایه برنامه بدن برگردونن

### کش پایگاه داده

پایگاه‌داده شما معمولا شامل یک سری لایه کش به صورت پیش‌فرض در تنظیماتش هست که برای کاربرادهای عمومی‌تر مورد استفاده فرار میگیره. تغییر این تنظیمات برای یک کاربرد خاص میتونه این افزایش کارایی رو حتی بیشتر هم بکنه.

### کش در برنامه

کش‌های داخل-حافظه مثل مِمکش و رِدیس ذخیره‌سازهای کلید-مقداری هستند که بین برنامه شما و منبع نگه داری داده‌ شما قرار میگیرن. از اونجایی که داده ها داخل رم نگه داری میشه، سرعت بیشتری نسبت به پایگاه داده های معمولی داره چرا که توی پایگاه‌داده، داده روی دیسک ذخیره میشه. رم نسبت به دیسک محدودتره بنابراین الگوریتم‌های [غیر معتبر کردن کش](https://en.wikipedia.org/wiki/Cache_algorithms)  مثل [آخرین نزدیکترین استفاده - اِل-آر-یو](https://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used) میتونه کمک کنه که آیتم‌های سرد رو غیر معتبر کنه و داده‌ها داغ‌تر رو توی رم نگه داره.(منظور از داغ، بیشتر مورد استفاده است و منظور از سرد، برعکس داغ)

رِدیس ویژگی‌ها بیشتر زیر رو هم داره:

* امکان دائمی کردن داده روی دیسک
* داده‌ساختارهای درونی مثل مجموعه‌های مرتب و لیست‌ها

سطح‌های مختلفی وجود دارند که میتونید کش کردن رو انجام بدید که به دو دسته کلی تقسیم میشن: **کوئری‌های پایگاه‌داده** و **اشیا**

* در سطح سطر
* در سطح کوئری
* Fully-formed serializable objects
* صفحات اچ-تی-ام-ال که به صور کامل رندر شدن

به طورکلی، شما بهتره که از کش کردن به صورت فایلی دوری کنین چرا که اسکیل-کردن خودکار و کلون کردن رو خیلی سخت میکنه.

### کش در سطح کوئری پایگاه داده

هرزمانی که شما کوئری به پایگاه داده میزنید،‌کوئری رو به صورت هش شده به عنوان کلید درنظر بگیرید و جوابش رو به عنوان مقدار توی کش ذخیره کنید. این روش از مشکلاتی که مربوط به انقضا میشه رنج میبره:

* پاک کردن نتایجی که حاضل کوئری های پیچیدس سخت میشه
* اگر یک قسمت از داده مثل یک سلول از یک جدول تغییر کنه، شما باید هرچی که کش کردید که شامل اون سلول میشه رو پاک کنید

### کش در سطح آبجکت

داده‌ تون رو به عنوان یک شی نگاه کنید، مثل همون کاری که توی برنام میکنید. مجموعه داده‌هاتون رو از توی پایگاه‌داده دربیارید و توی یک کلاس یا یه ساختمان داده ذخیره کنید

* اگر داده تغییر کرد، اون شی رو پاک کنید از کش
* امکان پردازش ناهمگام رو هم فراهم میکنه: وُرکرها آخرین اشیا کش شده رو جمع میکنن

پیشنهاداتی برای اینکه چیا رو کش کنید:

* سِشِن کاربر
* صفحات کاملا رندرشده
* Activity streams
* User graph data

### چه زمانی کش را آپدیت کنیم

از اونجایی که شما فقط میتونید یه بخش محدودی از داده‌ها رو بزارید توی کش، لازم دارید بدونید که چه استراتژی برای اپدیت کردن کشتون برای کاربرد شما بهتره

#### Cache-aside

<p align="center">
  <img src="http://i.imgur.com/ONjORqk.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Source: From cache to in-memory data grid</a></i>
</p>

> Storage: اِستورج

برنامه مسول نوشتن و خواندن از اِستورج هست. کش با خود استورج به صورت مستقیم در ارتباط نیست. برنامه کارهای زیر رو انجام میده:

* دنبال یک آیتم خاص توی کش میگرده، که نتیجش این میشه که آیتم داخل کش نیست
* اون آیتم رو از پایگاه داده لود میکنه
* اون آیتم رو توی کش اضافه میکنه
* آیتم رو بر میگردونه
</div>

```
def get_user(self, user_id):
    user = cache.get("user.{0}", user_id)
    if user is None:
        user = db.query("SELECT * FROM users WHERE user_id = {0}", user_id)
        if user is not None:
            key = "user.{0}".format(user_id)
            cache.set(key, json.dumps(user))
    return user
```
<div dir="rtl">

[مِم-کش-دی](https://memcached.org/) معمولا به این حالت ازش استفاده میشه

عملیات‌های خواندن که بعد از این میاد، و مربوط به همون داده ‌ای هست که توی کش نوشته شده، سریع‌تر انجام میشه. کش-اِساید به تحت عنوان بارگذاری تنبل هم گفته میشه. فقط داده‌ای که درخواست داده میشه، کش میشه که این باعث میشه تا کش با داده‌هایی که درخواست داده نشدن پر نشه.

##### معایب : cache-aside

* هر نبودن در کش باعث میشه تا ۳ مسیر طی بشه که این خودش باعث میشه که تاخیر قابل توجهی ایجاد بشه.
* داده میتونه غیرمعتبر بشه اگر که داخل پایگاه داده تغییر کرده باشه. این مشکل با ست کردن یک تام-تو-لیو برطرف میشه به اینصورت که کش مجبوره بعد این مدت اپدیت بشه. یا با استفاده از روش رایت-ثُرو میشه این مشکل رو برطرف کرد.
* اگر نودی فِیل بشه، اون با یک نود جدید جایگزین میشه و نود خالی باعث میشه تا تاخیر افزایش پیدا کنه

#### Write-through

<p align="center">
  <img src="http://i.imgur.com/0vBc0hN.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>
</p>

برنامه کش رو به عنوان استور اصلی داده‌ها استفاده میکنه یعنی نوشتن و خوندن داده رو در اون انجام میده در حالی که کش مسول نوشتن و خوندن توی پایگاه‌داده هست:

* برنامه یک آیتم رو به کش اضافه میکنه یا آپدیتش میکنه
* کش به صورت همگام عملیات‌های نوشتن رو توی پایگاه داده انجام میشده
* بعد نتیجه برمیگرده

کد برنامه:
</div>

```
set_user(12345, {"foo":"bar"})
```
<div dir="rtl">

کد کش:
</div>

```
def set_user(user_id, values):
    user = db.query("UPDATE Users WHERE id = {0}", user_id, values)
    cache.set(user_id, user)
```
<div dir="rtl">

این روش با توجه به عملیات نوشتنی که داره، به طور کلی کُند هست اما عملیات‌های خوندنی که در ادامه اتفاق میوفته خیلی سریع هستند. کاربران معمولا زمانی که میخوان به روز رسانی داده‌هاشون رو انجام بدن خیلی نسبت تاخیر واکنش نشون نمیدن نسبت به زمانی که قصد دارن داده‌ها رو بخونن. داده‌ها داخل کش غیرمعتبر نمیشن

##### معایب : write-through

* وقتی نود جدید درست میشه به خاطر اسکیل کردن یا فِیل شدن، نود جدید آیتم‌ها رو کش نمیکنه تا زمانیکه در پایگاه داده به روز رسانی بشن. استفاده از روش کش-اِساید با این روش میتونه این مشکل رو برطرف کنه.
* بیشتر داده‌هایی که نوشته میشن تو کش ممکنه خونده نشن که البته میتونه با استفاده از تای-تو-لیو این تاثیر رو کم کرد..

#### Write-behind (write-back)

<p align="center">
  <img src="http://i.imgur.com/rgSrvjG.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>
</p>

 در این روش برنامه به صورت زیر عمل میکنه:

* یک آیتم به کش اضافه میکنه یا آپدیت میکنه
* به صورت ناهمگام آیتم رو توی اون منبع ذخیره مینویسه که باعث میشه تا کارایی سیستم بهبود پیدا کنه

##### معایب : write-behind

* اگر قبل از اینکه محتوای داخل کش مورد استفاده قرار بگیره، کش پایین بیاد ممکنه که داده‌ها رو از دست بدیم.
* پیاده سازی این روش نسبت به روش های کش-اساید و یا رایت-ثُرو پیچیده‌تر هست.

#### Refresh-ahead

<p align="center">
  <img src="http://i.imgur.com/kxtjqgE.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Source: From cache to in-memory data grid</a></i>
</p>

شما میتونید کش رو طوری تنظیم کنید که به صورت خودکار هر آیتم داخل کش که اخیر مورد استفاده قرار گرفته رو قبل از زمان انقضاش رِفرِش کنید

 اگر کش بتونه به دقت تشخیص بده که کدوم آیتم احتمالا در آینده مورد نیاز خواهد بود،‌ این روش میتونه باعث بشه که تاخیر کاهش پیداکند نسبت حالت رید-ثُرو .

##### معایب : refresh-ahead

* اگر پیش‌بینی اینکه کدوم آیتم در آینده مورد نیاز خواهد بود به خوبی انجام نشه باعث میشه تا کارایی کاهش پیدا کنه نسبت به حالتی که از این مود استفاده نشه.

### معایب : Cache

* نیاز داره سازگاری بین کش‌ها و منابع درستیشون، مثل پایگاه داده‌ها، به وسیله‌ی [غیرمعتبرسازی کش](https://en.wikipedia.org/wiki/Cache_algorithms) تامین بشه.
* نیاز داره که تغییراتی در برنامه ایجاد بشه، مثل اضافه کردن رِدیس یا مِم-کش-دی
* غیرمعتبرسازی کش مشکل دشواری هست و یه پیچیدگی در مورد زمان آپدیت کش به وجود میاره.

### منابع برای مطالعه بیشتر
</div>

* [From cache to in-memory data grid](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)
* [Scalable system design patterns](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)
* [Introduction to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale/)
* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Scalability](http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
* [AWS ElastiCache strategies](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)
* [Wikipedia](https://en.wikipedia.org/wiki/Cache_(computing))
<div dir="rtl">

## Asynchronism

<p align="center">
  <img src="http://i.imgur.com/54GYsSx.png">
  <br/>
  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Source: Intro to architecting systems for scale</a></i>
</p>

جریان کاری ناهمگام باعث میشه تا زمان درخواست برای عملیات‌های سنگین کاهش پیدا کنه که اگر معمولی به صورت همگام بود زمان بیشتری میگرفت. همینطور باعث میشه تا کارهای زمانبر مثل اگریگیت کردن داده‌ها از قبل انجام بشن.



### Message queues

صف‌‌های پیام، پیام‌ها را میگیرند،‌نگه میدارن و بعد میرسونن. اگر یه عملیاتی برای اجرای همگام خیلی کُند باشه میتونید از یه صف با جریان کاری زیر استفاده کنید:

* یک برنامه یک کار رو به صف اضافه میکنه، بعد به کاربر از وضعیت کاری که فرستاده اطلاع میده.
* یک وُرکر کار رو از صف بر میداره پردازش میکنه و بعد سیگنالی مبنی بر این که کار تموم شده ارسال میکنه.

روند اجرایی کاربر بلاک نمیشه و کار در پس‌زمینه در حال انجامه. در این مدت کلاینت میتونه یه پردازش خیلی کمی انجام بده و نشون بده که اون کار تموم شده(به کاربر). برای مثال، اگر پستی توییت میشه، پست میتونه همون لحظه به تامیلاینتون اضافه بشه اما ممکنه یکم زمان ببره تا قبل از اینکه به تمام فالورهای شما برسه.

**ردیس** یک بروکر پیام ساده و کاربردی است اما پیام‌ها میتونن گم بشن داخلش.

**رَبیت-اِم-کیو** معروفه اما  باید از 'پروتکل اِی-اِم-کیو-پی' استفاده کنید و نود‌ها رو خودتون رو مدیریت کنید.

**آمازون اِس-کیو-اِس** به صورت هاست شده هست اما ممکنه که تاخیر زیادی داشته باشه و امکان داره که یک پیام ۲ بار دریافت بشه.

### Task queues

صف‌ تسک‌ها، تسک‌ها و داده‌های مربوط به اون رو میگیره، اجراشون میکنه بعد نتایجش رو برمیگردونه. تسک‌ها میتونن زمانبندی رو پشتیبانی کنن و میتونه به برای کارهایی که از نظر محاسباتی خیلی سنگینه استفاده بشه و در پس‌زمینه اجراشون بکنه.

**سِلِری** پشتیبانی برای زمانبندی داره و به صورت رسمی از پایتون پشتیبانی میکنه.

### Back pressure

اگر صف‌ها شروع به رشد زیادی بکنه، سایز صف میتونه از میزان حافظه بیشتر بشه، باعث بشه که داده‌ها توی کش پیدا نشن، باعث بشه خواندن از دیسک زیاد بشه و حتی کارایی رو کمتر میکنه. [بک-پِرِشِر](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)  میتونه با محدودیت گذاشتن روی  سایز صف، نرخ بازدهی بالا و زمان پاسخگویی مناسبی برای کارهایی که در داخل صف هستند رو باعث بشه. زمانی که صف پر میشه، کلاینت های جوابی مبنی بر این که سرور مشغوله یا کد اچ-تی-تی-پی ۵۰۳ میگیرن تا بعدا دوباره درخواست رو بفرستن و امتحان کنن. کلاینت ها میتونن درخواست رو بعدا تکرار کنن، شاید با یک [بک-آف نمایی](https://en.wikipedia.org/wiki/Exponential_backoff) .

### معایب : asynchronism

* کاربردهایی که نیاز به محاسبات سنگین و جریان کاری بلادرنگ نداره بهتره تا از مدل‌های اجرایی همگام استفاده کنه چون که استفاده از صف باعث میشه که پیچیدگی و تاخیر زیاد بشه.

### منابع برای مطالعه بیشتر
</div>

* [It's all a numbers game](https://www.youtube.com/watch?v=1KRYH75wgy4)
* [Applying back pressure when overloaded](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)
* [Little's law](https://en.wikipedia.org/wiki/Little%27s_law)
* [What is the difference between a message queue and a task queue?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)
<div dir="rtl">

## ارتباط

<p align="center">
  <img src="http://i.imgur.com/5KeocQs.jpg">
  <br/>
  <i><a href=http://www.escotal.com/osilayer.html>Source: OSI 7 layer model</a></i>
</p>

### Hypertext transfer protocol (HTTP)

اچ-تی-تی-پی یک روش برای کدگذاری داده برای انتقال داده بین کلاینت و سرور است. این متد یک پروتکل درخواست/پاسخ هست، یعنی: کلاینت ها درخواستشون رو میفرستند و سرورها جواب‌هاشونو با محتوا و استاتوس، که وضعیت کامل شدن درخواست هست، به اونها میدن. اچ-تی-تی-پی خود-شامل هست یعنی اینکه اجازه میده که درخواستها و پاسخها از روترهای میانی مسیر و سروهای سرراه بگذره درحالی که این لایه‌های میانی باعث میشن که لودبالانسینگ، کش کردن، رمزنگاری، و فشرده سازی اتفاق بیوفته.

یک درخواست ساده اچ-تی-تی-پی شامل یک فعل(متد) و یک ریسورس یا منبع(اِند-پوینت) هست. در ادامه افعال رایج در اچ-تی-تی-پی آورده شده:



| فعل    |                                  توضیحات | Idempotent* | امن  |                              قابل کش شدن |
| ------ | ---------------------------------------: | :---------: | :--: | ---------------------------------------: |
| GET    |                      یک ریسورس رو میخونه |     بله     | بله  |                                      بله |
| POST   | یک ریسورس میسازه یا یک فرآیند رو آغاز میکنه که داده رو هندل کنه |     نه      |  نه  | اگر پاسخ دارای اطلاعاتی باشه که تازه باشه |
| PUT    |        یک ریسورس میسازه یا جایگزین میکنه |     بله     |  نه  |                                       نه |
| PATCH  |    یک ریسورس رو یه بخشیش رو به روز میکنه |     نه      |  نه  | اگر پاسخ دارای اطلاعاتی باشه که تازه باشه |
| DELETE | یک ریسورس رو پاک میکنهDeletes a resource |     بله     |  نه  |                                       نه |

*میتونه به تعداد دفعات زیادی فراخوانی بشه بدون اینکه نتیجش تغییری کنه

اچ-تی-تی-پی یک پروتکل لایه برنامه است که به پروتکل‌های سطح پایین تری مثل **تی-سی-پی** و **یو-دی-پی** وابسته هست.

> TCP: تی-سی-پی, UDP: یو-دی-پی

#### منابع برای مطالعه بیشتر : HTTP
</div>

* [What is HTTP?](https://www.nginx.com/resources/glossary/http/)
* [Difference between HTTP and TCP](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)
* [Difference between PUT and PATCH](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)
<div dir="rtl">

### Transmission control protocol (TCP)

<p align="center">
  <img src="http://i.imgur.com/JdAsdvG.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Source: How to make a multiplayer game</a></i>
</p>

تی-سی-پی یک پروتکل ارتباط-محور روی یک [شبکه آی-پی](https://en.wikipedia.org/wiki/Internet_Protocol)  هست. ایجاد و خاتمه یک کانکشن با استفاده از یک [هندشِیک](https://en.wikipedia.org/wiki/Handshaking) انجام میشه. تمام پکت‌هایی که ارسال میشن تضمین میشن که به ترتیب و بدون اختلال به مقصد برسه و از طریق موارد زیر:

* شماره سیکوئنس و [فیلد‌های چِک-سام](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation) برای هر پکِت
* پکِت‌های [تایید](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)) و دوباره ارسال‌هایی که به صورت خودکار انجام میشن.

اگر ارسال کننده پاسخ درست دریافت نکند، دوباره پکِت‌ها را میفرستد. اگر تعداد متعددی تایم-اُوت اتفاق بویفته، کانکشن قطع میشه. تی-سی-پی [کنترل جریان](https://en.wikipedia.org/wiki/Flow_control_(data)) و [کنترل ازدحام](https://en.wikipedia.org/wiki/Network_congestion#Congestion_control) رو اجرا میکنه. این تضمین‌ها باعث میشه تا تاخیر به وجود بیاد و به طور کلی باعث بشه تا نسبت به انتقال به روش یو-دی-پی، کمتر بهینه باشه.

برای اطمینان از نرخ بازدهی بالا، وب سرور‌ها تعداد زیادی کانکشن تی-سی-پی رو باز نگه میدارن، که این باعث میشه تا میزان مصرف حافظه زیاد بشه. تعداد کانکشن بازِ زیاد بین تِرِدهای یک وب سرور و به عنوان مثال یک سرور [مِم-کش-دی](#memcached)  میتونه پرهزینه باشه. [کانکشن پولینگ](https://en.wikipedia.org/wiki/Connection_pool)  میتونه زمانیکه امکانش هست به یو-دی-پی سويیچ انجام بده.

تی-سی-پی برای کارهایی که نیاز به اطمینان بالایی هست و از نظر زمانی حساس نیست مناسبه. بعضی مثال‌هاش شامل وب سرورها،‌ اطلاعات پایگاه داده، اِس-اِم-تی-پی، اِف-تی-پی، و اِس-اِس-اِچ هست.

> SMTP: اِس-اِم-تی-پی ,FTP: اِف-تی-پی, SSH: اِس-اِس-اِچ

زمان‌هایی که تی-سی-پی باید به جای یو-دی-پی استفاده بشه:

* قصد دارید که داده‌ها دست نخورده برسن
* قصد بهترین تخمین از بازدهی شبکه را داشته باشید

> Intact: دست نخورده, High Available: اطمینان بالا

### User datagram protocol (UDP)

<p align="center">
  <img src="http://i.imgur.com/yzDrJtA.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Source: How to make a multiplayer game</a></i>
</p>

یو-دی-پی کانکشن-لِس هست. دیتاگرام‌ها(مشابه پکِت‌ها) فقط در سطح دیتاگرام تضمین میشن. دیتا گرام‌ها ممکنه که خارج از ترتیبشون به مقصد برسن یا کلا نرسن. یو-دی-پی از کنترل ازدحام پشتیبانی نمیکنه. مستقل از تضمین‌هایی که تی-سی-پی پشتیبانی میکنه، یو-دی-پی به طور کلی بهینه‌تر هست.

یو-دی-پی میتونه برادکست کنه،‌ دیتا گرام‌ها رو به تمام دیوایس‌های روی سابنت بفرسته. این امکان برای [دی-اِچ-سی-پی]() خوبه چرا که کلاینت‌ هنوز آدرس آی-پی نگرفته، بنابراین یک راه برای جلوگیری کردن از اینه که تی-سی-پی بدون آدرس آی-پی شروع به ارسال کنه.

یو-دی-پی کمتر قابل اطمینانه ما برای مواردی که نیاز بلادرنگ دارند مثل وُیپ، چت تصویری، استریم کردن، و بازی‌های بلادرنگ چند نفره به خوبی عمل میکنه.

> VoIP: وُیپ, Streaming: استریم کردن , Realtime: بلادرنگ

زمانی از یو-دی-پی به جای تی-سی-پی استفاده کنید که:

* نیاز به کمترین تاخیر دارید.
* دیر رسیدن دیتا از گم شدنش خیلی بدتره
* میخواید اصلاح خطای خودتون رو پیاده سازی کنید

#### منابع بیشتر برای مطالعه : TCP و UDP
</div>

* [Networking for game programming](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)
* [Key differences between TCP and UDP protocols](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)
* [Difference between TCP and UDP](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)
* [Transmission control protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)
* [User datagram protocol](https://en.wikipedia.org/wiki/User_Datagram_Protocol)
* [Scaling memcache at Facebook](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)
<div dir="rtl">

### Remote procedure call (RPC)

<p align="center">
  <img src="http://i.imgur.com/iF4Mkb5.png">
  <br/>
  <i><a href=http://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview/>Source: Crack the system design interview</a></i>
</p>

در یک آر-پی-سی کلاینت باعث اجرای یک رویه در فضای آدرس متفاوت،که معمولا یک سرور ریموت هست، میشه. این رویه طوری کد شده که انگار به صورت محلی فراخوانیش انجام میشه، جزییات اینکه چهطور ارتباط با سرور صورت میگیره رو از برنامه کلاینت پنهان میکنه. فراخوانی‌های راه‌دور معمولا کندتر هستند و کمتر قابل اطمینانن نسبت به فراخوانی‌های محلی بنابراین بهتره که فراخوانی‌های راه‌دور رو از فراخوانی‌های محلی متمایز کنیم. چارچوبهای شناخته شده  آر-پی -سی شامل [پروتو-باف](https://developers.google.com/protocol-buffers/)، [ثریفت](https://thrift.apache.org/) , [آو-رو](https://avro.apache.org/docs/current/)  هستند.

> Protobuf: پروتو-باف, Thrift: ثریفت, Avro: آو-رو

آر-پی-سی یک پروتکل درخواست-جواب هست:

* **Client program** - رویه‌ی کلاینت-اِستاب رو فراخوانی میکنه. پارامتر‌ها شبیه به فراخوانی محلی داخل یک پشته نوشته میشن.
* **Client stub procedure** - آی-دی رویه و آرگومان‌های اون رو مارشال میکنه(جمع میکنه) داخل درخواست.
* **Client communication module** - سیستم عامل پیام رو از کلاینت به سرور میفرسته.
* **Server communication module** - سیستم عامل پکت‌های ورودی رو به رویه استاب سرور میده
* **Server stub procedure** -  نتایج بازمیشن(آن-مارشال)، رویه‌ای از سرور که با آی-دی رویه مطابقت داشته باشه با آرگومان‌های داده‌شده اجرا میشه.
* سرور در پاسخ مراحل بالا رو به صورت معکوس انجام میده

نمونه فراخوانی آر-پی-سی:
</div>

```
GET /someoperation?data=anId

POST /anotheroperation
{
  "data":"anId";
  "anotherdata": "another value"
}
```
<div dir="rtl">

تمرکز آر-پی-سی روی بیان رفتارهاست. آر-پی-سی‌ها معمولا برای دلایلی مثل کارایی برای ارتباطات داخلی استفاده میشن، همینطور شما میتونید از فراخوانی‌های نِیتیو که انجام میدید و مناسب کاربردتون هست استفاده کنید.

> Native Calls: , Internal Communication: ارتباطات داخلی

زمانی از یک کتابخونه نِیتو(که تحت عنوان اِس-دی-کِی هم شناخته میشن) استفاده کنید که:

* پلتفرم مقصدتون رو میشناسید
* میخواید که نحوه دسترسی به "منطق" تون رو کنترل کنید
* میخواید نحوه کنترل خطاهایی که توی کتابخونتون اتفاق میوفتن رو مدیریت کنید
* کارایی و تجربه‌کاربری یکی از دغدغه‌های اصلی شماست

 اِی-پی-آی‌های اچ-تی-تی-پی که از **رِست** پیروی میکنن بیشتر برای اِی-پی-آی‌های عمومی مورد استفاده قرار میگیرن.

#### معایب: RPC

* کلاینت‌های آر-پی-سی خیلی وابسته میشن به پیاده سازی سرویس‌ها

* اِی-پی-آی‌های جدید باید برای هر عمل جدید یا کاربرد جدید تعریف بشن

* دیباگ کردن آر-پی-سی میتونه دشوار باشه

* ممکنه شما نتونید از تکنولوژی‌هایی که درحال حاضر هستند استفاده کنید. برای مثال، ممکنه نیاز باشه تا تلاش بیشتری بکنید تا مطمئن بشید که [فراخوانی‌های آر-پی-سی به درستی کش شدن](http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) روی سرور‌های کش، مثل [اِس-کویید](http://www.squid-cache.org/)


### Representational state transfer (REST)

رِست یک نوع استایل معماری هست که در جایی که کلاینت‌ها روی یک سری ریسورس که سرور مدیرتش میکنه قراره کاری انجام بدن، مدل کلاینت/سرور رو ایجاب میکنه . سرور یک نمایشی از ریسورس‌ها رو ارائه میکنه و همچنین عملکرد‌هایی که میتونه هم تغییر ایجاد کنه یا یک نمایش جدیدی از ریسورس رو بده. تمام ارتباطات باید بدون حالت و قابل کش کردن باشه.

چهار کیفیت از یک واسط رِست-فول وجود داره:

* **Identify resources (URI in HTTP)** - از یک یو-آر-آی مشابه برای هر عملیاتی استفاده میکنه
* **Change with representations (Verbs in HTTP)** - از افعال، هدر‌ها و بادی استفاده میکنه.
* **Self-descriptive error message (status response in HTTP)** - از کدهای وضعیت استفاده میکنه و دوباره چرخ رو اختراع نمیکنه.
* **[HATEOAS](http://restcookbook.com/Basics/hateoas/) (HTML interface for HTTP)** - وب سرویس شما بهتره که به طور کامل در مرورگر قابل دسترسی باشه

> URI: یو-آر-آی, Body: بادی, Header: هدر , Status Code: کد وضعیت, RESTfull: رِست-فول

نمونه‌ای از فراخوانی رِست

```
GET /someresources/anId

PUT /someresources/anId
{"anotherdata": "another value"}
```

رِست تمرکزش روی نمایش داده است. این معماری وابستگی بین کلاینت/سرور رو کم میکنه و معمولا برای اِی-پی-آی‌های اچ-تی-تی-پی عمومی مورد استفاده قرار میگیره. رِست یه روش کلی‌تری و یکدست‌تری برای به نمایش گذاشتن ریسورس‌ها استفاده میکنه، که از طریق یو-آر-آی، [نمایش از طریق هِدِرها](https://github.com/for-GET/know-your-http-well/blob/master/headers.md) ، و اکشن‌ها که به واسطه فعل‌هایی مثل گِت، پُست، پوت، دیلیت و پَچ است. با توجه به این که فاقد حالته، رِست برای اسکیل کردن افقی و پاتیشن‌بندی خیلی مناسبه.

> GET: گِت, POST: پُست , PUT: پوت , DELETE: دیلیت , PATCH: پَچ
> Stateless: فاقد حالت

#### معایب‌ : REST

* باتوحه به این که تمرکز رِست روی به نمایش گذاشتن داده‌هاس، برای ریسورس‌هایی که به صورت معمولی و سلسله مراتبی مدیرت میشن مناسب نیست. برای مثال، برگردوندن لیست آپدیت‌های رکوردها توی رنج ۱ ساعت پیش که با یک سری رخ‌دادهای خاص مَچ شده باشه چیزی نیست که بشه به صورت مسیر، توی یو-آر-اِل اچ-تی-تی-پی، اونو به راحتی نشون داد. در صورت استفاده از رِست،‌باید این کار به وسیله ترکیبی از یو-آر-آی‌ها، کوئری‌ پارامتر‌ها و احتمالا با یک ریکوست بادی پیاده سازی بشه.
* رِست معمولا روی چندتا فعل محدود(گِت، پُست، پوت، دیلیت و پَچ) تمرکز داره که بعضی وقتا برای کاربرد شما مناسب نیست. برای مثال،‌ انتقال مستنداتی که دیگه منتقضی شدن به فولدر آرشیو ممکنه که خیلی تر و تمیز با این فعل‌ها نشه بیانش کرد.
* گرفتن ریسورس های پیچیده با ساختار سلسله مراتبی تودرتو احتیاج داره که تعداد رفت و  برگشت زیاده رو بین کلاینت و سرور شاهد باشیم تا سرور فقط یک صفحه رو نمایش بده به عنوان مثال، گرفتن محتوای یک پست از بلاگ و کامنت هایی که روی اونه. برای برنامه های موبایل در شرایطی که باید بین شبکه‌های مختلفی کار کنند، این رفت و برگشت ها خیلی مورد علاقه نیست.
* به مرورزمان، تعداد فیلدهای بیشتری ممکنه که به پاسخ اِی-پی-آی اضافه بشه و کلاینت‌های قدیمی فیلدهای جدید رو هم میگیرن حتی اون دسته از فیلدهایی که بدردشون نمیخوره که این باعث میشه سایز بدنه ارسالی زیاد بشه و این خودش یعنی افزایش تاخیر.

### مقایسه فراخوانی‌های آر-پی-سی و رِست
</div>

| عملیات                          | RPC                                      | REST                                     |
| ------------------------------- | ---------------------------------------- | ---------------------------------------- |
| Signup                          | **POST** /signup                         | **POST** /persons                        |
| Resign                          | **POST** /resign<br/>{<br/>"personid": "1234"<br/>} | **DELETE** /persons/1234                 |
| Read a person                   | **GET** /readPerson?personid=1234        | **GET** /persons/1234                    |
| Read a person’s items list      | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items              |
| Add an item to a person’s items | **POST** /addItemToUsersItemsList<br/>{<br/>"personid": "1234";<br/>"itemid": "456"<br/>} | **POST** /persons/1234/items<br/>{<br/>"itemid": "456"<br/>} |
| Update an item                  | **POST** /modifyItem<br/>{<br/>"itemid": "456";<br/>"key": "value"<br/>} | **PUT** /items/456<br/>{<br/>"key": "value"<br/>} |
| Delete an item                  | **POST** /removeItem<br/>{<br/>"itemid": "456"<br/>} | **DELETE** /items/456                    |
<p align="center">
  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>Source: Do you really know why you prefer REST over RPC</a></i>
</p>
<div dir="rtl">

#### منابع بیشتر برای مطالعه : RPC و REST
</div>

* [Do you really know why you prefer REST over RPC](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)
* [When are RPC-ish approaches more appropriate than REST?](http://programmers.stackexchange.com/a/181186)
* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)
* [Debunking the myths of RPC and REST](http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)
* [What are the drawbacks of using REST](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)
* [Crack the system design interview](http://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview/)
* [Thrift](https://code.facebook.com/posts/1468950976659943/)
* [Why REST for internal use and not RPC](http://arstechnica.com/civis/viewtopic.php?t=1190508)
<div dir="rtl">

## امنیت

این قسمت ممکنه شامل یه سری به روز رسانی ها بشه. قسمت  [همکاری](#همکاری) رو بررسی کنید.

  امنیت یک مبحث گسترده‌ای هست. احتمالا نیازی ندارید که بیشتر از مسايل پایه‌ای رو در مورد امنیت بدونید مگر اینکه تجربه‌ی خوبی در این زمینه یا پیش‌زمینه امنیت داشته باشید و یا قصد دارید که برای پوزیشنی که نیاز به دانش امینت داره برید:
  </div>
  
* Encrypt in transit and at rest.
* Sanitize all user inputs or any input parameters exposed to user to prevent [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) and [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).
* Use parameterized queries to prevent SQL injection.
* Use the principle of [least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege).
<div dir="rtl">

### منابع برای مطالعه بیشتر
</div>

* [Security guide for developers](https://github.com/FallibleInc/security-guide-for-developers)
* [OWASP top ten](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)
<div dir="rtl">

## پیوست

ممکنه از شما بخوان که یه سری محاسبات سریعی رو انجام بدید. برای مثال ممکنه نیاز داشته داشته بدونید که چقدر زمان نیازه تا ۱۰۰ تصویر ثامب-نِیل از روی دیسک تولید بشه یا اینکه چقدر حافظه یک ساختمان داده خاص نیاز داره. **جدول اعداد توان ۲** و **اعداد تاخیری که هر برنامه نویسی باید بدونه** یه منبع مناسب هست برای این کار.

### جدول اعداد توان ۲
</div>

```
Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB
```
<div dir="rtl">

#### منابع برای مطالعه بیشتر
</div>

* [Powers of two](https://en.wikipedia.org/wiki/Power_of_two)
<div dir="rtl">

### اعداد تاخیری که هر برنامه نویس باید بدونه
</div>

```
Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                          100   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from disk    30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns
```
<div dir="rtl">

متریک‌ها دم دست براساس اعداد بالا به صورت زیره:
</div>

* Read sequentially from disk at 30 MB/s
* Read sequentially from 1 Gbps Ethernet at 100 MB/s
* Read sequentially from SSD at 1 GB/s
* Read sequentially from main memory at 4 GB/s
* 6-7 world-wide round trips per second
* 2,000 round trips per second within a data center
<div dir="rtl">

#### مصور شده اعداد تاخیر

![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)

#### منابع برای مطالعه بیشتر
</div>

* [Latency numbers every programmer should know - 1](https://gist.github.com/jboner/2841832)
* [Latency numbers every programmer should know - 2](https://gist.github.com/hellerbarde/2843375)
* [Designs, lessons, and advice from building large distributed systems](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)
* [Software Engineering Advice from Building Large-Scale Distributed Systems](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)
<div dir="rtl">

### سوالات بیشتر مصاحبه طراحی سیستم

> سوالات رایج مصاحبه طراحی سیستم به همراه لینک به منابعی که روش حلش رو ارائه کرده
</div>

| سوال                                     | منبع یا منابع                            |
| ---------------------------------------- | ---------------------------------------- |
| Design a file sync service like Dropbox  | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| Design a search engine like Google       | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |
| Design a scalable web crawler like Google | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |
| Design Google docs                       | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |
| Design a key-value store like Redis      | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| Design a cache system like Memcached     | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Design a recommendation system like Amazon's | [hulu.com](http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |
| Design a tinyurl system like Bitly       | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |
| Design a chat app like WhatsApp | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html)
| Design a picture sharing system like Instagram | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |
| Design the Facebook news feed function | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |
| Design the Facebook timeline function | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |
| Design the Facebook chat function | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |
| Design a graph search function like Facebook's | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |
| Design a content delivery network like CloudFlare | [cmu.edu](http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&context=compsci) |
| Design a trending topic system like Twitter's | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |
| Design a random ID generation system | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |
| Return the top k requests during a time interval | [ucsb.edu](https://icmi.cs.ucsb.edu/research/tech_reports/reports/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |
| Design a system that serves data from multiple data centers | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |
| Design an online multiplayer card game | [indieflashblog.com](http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |
| Design a garbage collection system | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |
| Design an API rate limiter | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) | 

| Add a system design question | [Contribute](#contributing) |
<div dir="rtl">

### معماری های دنیای واقعی

> مقاله‌هایی در مورد اینکه سیستم‌های دنیای واقعی به چه‌صورتی طراحی شده‌اند

<p align="center">
  <img src="http://i.imgur.com/TcUo2fw.png">
  <br/>
  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>Source: Twitter timelines at scale</a></i>
</p>

**روی جزيات مقاله‌های زیر تمرکز نکنید،‌در عوض:**

* اصول مشترک، تکنولوژی‌های مرسوم، و الگوهایی که در این مقالات استفاده شده رو پیدا کنید.
* اینکه چه کامپوننتی چه مساله‌ای رو حل میکنه، کجا کار میکنه، و کجا کار نمیکنه رو بررسی کنید
* هرچی یادگرفتید رو مرور کنید
</div>

| نوع             | سیستم                                    | منبع یا منابع                            |
| --------------- | ---------------------------------------- | ---------------------------------------- |
| Data processing | **MapReduce** - Distributed data processing from Google | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |
| Data processing | **Spark** - Distributed data processing from Databricks | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |
| Data processing | **Storm** - Distributed data processing from Twitter | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |
|                 |                                          |                                          |
| Data store      | **Bigtable** - Distributed column-oriented database from Google | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |
| Data store      | **HBase** - Open source implementation of Bigtable | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |
| Data store | **Cassandra** - Distributed column-oriented database from Facebook | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666)
| Data store | **DynamoDB** - Document-oriented database from Amazon | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |
| Data store | **MongoDB** - Document-oriented database | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |
| Data store | **Spanner** - Globally-distributed database from Google | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |
| Data store | **Memcached** - Distributed memory caching system | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Data store | **Redis** - Distributed memory caching system with persistence and value types | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| | | |
| File system | **Google File System (GFS)** - Distributed file system | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |
| File system | **Hadoop File System (HDFS)** - Open source implementation of GFS | [apache.org](https://hadoop.apache.org/docs/r1.2.1/hdfs_design.html) |
| | | |
| Misc | **Chubby** - Lock service for loosely-coupled distributed systems from Google | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |
| Misc | **Dapper** - Distributed systems tracing infrastructure | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf)
| Misc | **Kafka** - Pub/sub message queue from LinkedIn | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |
| Misc | **Zookeeper** - Centralized infrastructure and services enabling synchronization | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |
| |یک معماری اضافه کنید | [همکاری](#همکاری) |
<div dir="rtl">

### معماری کمپانی‌ها
</div>

| Company        | Reference(s)                             |
| -------------- | ---------------------------------------- |
| Amazon         | [Amazon architecture](http://highscalability.com/amazon-architecture) |
| Cinchcast      | [Producing 1,500 hours of audio every day](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |
| DataSift       | [Realtime datamining At 120,000 tweets per second](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |
| DropBox        | [How we've scaled Dropbox](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| ESPN           | [Operating At 100,000 duh nuh nuhs per second](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |
| Google         | [Google architecture](http://highscalability.com/google-architecture) |
| Instagram      | [14 million users, terabytes of photos](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[What powers Instagram](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |
| Justin.tv      | [Justin.Tv's live video broadcasting architecture](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |
| Facebook       | [Scaling memcached at Facebook](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: Facebook’s distributed data store for the social graph](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Facebook’s photo storage](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf) |
| Flickr         | [Flickr architecture](http://highscalability.com/flickr-architecture) |
| Mailbox        | [From 0 to one million users in 6 weeks](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |
| Pinterest      | [From 0 To 10s of billions of page views a month](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[18 million visitors, 10x growth, 12 employees](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |
| Playfish       | [50 million monthly users and growing](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |
| PlentyOfFish   | [PlentyOfFish architecture](http://highscalability.com/plentyoffish-architecture) |
| Salesforce     | [How they handle 1.3 billion transactions a day](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |
| Stack Overflow | [Stack Overflow architecture](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |
| TripAdvisor    | [40M visitors, 200M dynamic page views, 30TB data](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |
| Tumblr         | [15 billion page views a month](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |
| Twitter        | [Making Twitter 10000 percent faster](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[Storing 250 million tweets a day using MySQL](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[150M active users, 300K QPS, a 22 MB/S firehose](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[Timelines at scale](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Big and small data at Twitter](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Operations at Twitter: scaling beyond 100 million users](https://www.youtube.com/watch?v=z8LU0Cj6BOU) |
| Uber           | [How Uber scales their real-time market platform](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html) |
| WhatsApp       | [The WhatsApp architecture Facebook bought for $19 billion](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |
| YouTube        | [YouTube scalability](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[YouTube architecture](http://highscalability.com/youtube-architecture) |
<div dir="rtl">

### وبلاگ‌های مهندسی کمپانی‌ها

> معماری‌ها برای کمپانی‌هایی که باهاشون قراره مصاحبه کنید
>
> سوالاتی که ممکنه باهاشون مواجه بشید، شاید در زمینه‌های مشابه باشه
</div>

* [Airbnb Engineering](http://nerds.airbnb.com/)
* [Atlassian Developers](https://developer.atlassian.com/blog/)
* [Autodesk Engineering](http://cloudengineering.autodesk.com/blog/)
* [AWS Blog](https://aws.amazon.com/blogs/aws/)
* [Bitly Engineering Blog](http://word.bitly.com/)
* [Box Blogs](https://www.box.com/blog/engineering/)
* [Cloudera Developer Blog](http://blog.cloudera.com/blog/)
* [Dropbox Tech Blog](https://tech.dropbox.com/)
* [Engineering at Quora](http://engineering.quora.com/)
* [Ebay Tech Blog](http://www.ebaytechblog.com/)
* [Evernote Tech Blog](https://blog.evernote.com/tech/)
* [Etsy Code as Craft](http://codeascraft.com/)
* [Facebook Engineering](https://www.facebook.com/Engineering)
* [Flickr Code](http://code.flickr.net/)
* [Foursquare Engineering Blog](http://engineering.foursquare.com/)
* [GitHub Engineering Blog](http://githubengineering.com/)
* [Google Research Blog](http://googleresearch.blogspot.com/)
* [Groupon Engineering Blog](https://engineering.groupon.com/)
* [Heroku Engineering Blog](https://engineering.heroku.com/)
* [Hubspot Engineering Blog](http://product.hubspot.com/blog/topic/engineering)
* [High Scalability](http://highscalability.com/)
* [Instagram Engineering](http://instagram-engineering.tumblr.com/)
* [Intel Software Blog](https://software.intel.com/en-us/blogs/)
* [Jane Street Tech Blog](https://blogs.janestreet.com/category/ocaml/)
* [LinkedIn Engineering](http://engineering.linkedin.com/blog)
* [Microsoft Engineering](https://engineering.microsoft.com/)
* [Microsoft Python Engineering](https://blogs.msdn.microsoft.com/pythonengineering/)
* [Netflix Tech Blog](http://techblog.netflix.com/)
* [Paypal Developer Blog](https://devblog.paypal.com/category/engineering/)
* [Pinterest Engineering Blog](http://engineering.pinterest.com/)
* [Quora Engineering](https://engineering.quora.com/)
* [Reddit Blog](http://www.redditblog.com/)
* [Salesforce Engineering Blog](https://developer.salesforce.com/blogs/engineering/)
* [Slack Engineering Blog](https://slack.engineering/)
* [Spotify Labs](https://labs.spotify.com/)
* [Twilio Engineering Blog](http://www.twilio.com/engineering)
* [Twitter Engineering](https://engineering.twitter.com/)
* [Uber Engineering Blog](http://eng.uber.com/)
* [Yahoo Engineering Blog](http://yahooeng.tumblr.com/)
* [Yelp Engineering Blog](http://engineeringblog.yelp.com/)
* [Zynga Engineering Blog](https://www.zynga.com/blogs/engineering)
<div dir="rtl">

#### منابع برای مطالعه بیشتر
</div>

* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)
<div dir="rtl">

لیست وبلاگ‌ها در اینجا نسبتا کوتاه‌تر نگه داشته میشه و ریپازیتوری زیر شامل لیست بلندی از این وبلاگ‌هاست که برای جلوگیری از دوباره نویسی در اینجا، فقط همین بخش کم آورده شده. وبلاگ مهندسی کمپانیتون روبه ریپازیتوری زیر اضافه کنید
</div>

> Engineering Blogs:  [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs) 
<div dir="rtl">

## تحت توسعه

اگر تمایل به اضافه کردن بخش یا کامل کردن قسمتی که در حال توسعه هست به [همکاری](#همکاری) مراجعه کنید.
</div>

* Distributed computing with MapReduce
* Consistent hashing
* Scatter gather
* [همکاری](#همکاری)

## Credits

Credits and sources are provided throughout this repo.
<div dir="rtl">

تشکر ویژه از :
</div>

* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)
* [Cracking the coding interview](https://www.amazon.com/dp/0984782850/)
* [High scalability](http://highscalability.com/)
* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)
* [shashank88/system_design](https://github.com/shashank88/system_design)
* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)
* [System design cheat sheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)
* [A distributed systems reading list](http://dancres.github.io/Pages/)
* [Cracking the system design interview](http://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview/)
<div dir="rtl">

## اطلاعات تماس

در صورتی که نیازه تا با من در مورد ایشوها، سوالها یا کامنت‌ها صحبت کنید، راحت باشید و ارتباط بگیرید.

اطلاعات تماس من روی [صفحه گیت-هاب](https://github.com/donnemartin) من قابل دسترسی هست.
</div>

## License

*I am providing code and resources in this repository to you under an open source license.  Because this is my personal repository, the license you receive to my code and resources is from me and not my employer (Facebook).*

    Copyright 2017 Donne Martin

    Creative Commons Attribution 4.0 International License (CC BY 4.0)

    http://creativecommons.org/licenses/by/4.0/
